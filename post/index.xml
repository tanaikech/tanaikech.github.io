<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on tanaike</title>
    <link>https://tanaikech.github.io/post/</link>
    <description>Recent content in Posts on tanaike</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Thu, 16 Feb 2017 11:53:50 +0900</lastBuildDate>
    <atom:link href="https://tanaikech.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Send E-mail with Excel file converted from Spreadsheet</title>
      <link>https://tanaikech.github.io/2017/02/16/send-e-mail-with-excel-file-converted-from-spreadsheet</link>
      <pubDate>Thu, 16 Feb 2017 11:53:50 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/02/16/send-e-mail-with-excel-file-converted-from-spreadsheet</guid>
      <description>&lt;p&gt;This sample script sends an e-mail with an Excel file exported from Spreadsheet as an attachment file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function excelSender() {
  var sheetID = [Sheet ID];
  var xlsxName = [Excel file name];
  var params = {
    &amp;quot;headers&amp;quot;: {Authorization: &amp;quot;Bearer &amp;quot; + ScriptApp.getOAuthToken()},
    &amp;quot;muteHttpExceptions&amp;quot;: true
  };
  var dUrl = &amp;quot;https://docs.google.com/feeds/download/spreadsheets/Export?key=&amp;quot; + sheetID + &amp;quot;&amp;amp;amp;exportFormat=xlsx&amp;quot;;
  var xlsxlFile = UrlFetchApp.fetch(dUrl, params).getBlob().setName(xlsxName);
  MailApp.sendEmail({
    to: [Mail address],
    subject: &amp;quot;sample subject&amp;quot;,
    body: &amp;quot;sample body&amp;quot;,
    attachments: [xlsxlFile]
  });
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Download a CSV File from Spreadsheet Using Google HTML Service</title>
      <link>https://tanaikech.github.io/2017/02/16/download-a-csv-file-from-spreadsheet-using-google-html-service</link>
      <pubDate>Thu, 16 Feb 2017 10:31:37 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/02/16/download-a-csv-file-from-spreadsheet-using-google-html-service</guid>
      <description>

&lt;p&gt;Here, I introduce how to download a CSV file from spreadsheet using Google HTML Service.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Using &amp;ldquo;onOpen()&amp;rdquo;, it addes menu for launching a dialog.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://tanaikech.github.io/img/170216a.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;After launching the dialog, &amp;ldquo;getFileUrl()&amp;rdquo; is launched by pushing a button. &amp;ldquo;getFileUrl()&amp;rdquo; exports a CSV file and outputs download URL.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The CSV file is downloaded by &amp;ldquo;executeDownload()&amp;rdquo;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;u&gt;Please put both HTML and GAS to a GAS project.&lt;/u&gt;&lt;/p&gt;

&lt;h2 id=&#34;html-download-html&#34;&gt;HTML : download.html&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    Download CSV?
    &amp;lt;form&amp;gt;
      &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;ok&amp;quot; onclick=&amp;quot;google.script.run
                                              .withSuccessHandler(executeDownload)
                                              .getFileUrl();&amp;quot; /&amp;gt;
    &amp;lt;/form&amp;gt;
  &amp;lt;/body&amp;gt;
  &amp;lt;script&amp;gt;
    function executeDownload(url) {
      window.location.href = url;
    }
  &amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gas&#34;&gt;GAS :&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function onOpen() {
  SpreadsheetApp.getUi()
                .createMenu(&#39;export&#39;)
                .addItem(&#39;export csv files&#39;, &#39;dialog&#39;)
                .addToUi();
}

function dialog() {
  var html = HtmlService.createHtmlOutputFromFile(&#39;download&#39;);
  SpreadsheetApp.getUi().showModalDialog(html, &#39;CSV download dialog&#39;);
}

function getFileUrl() {
    var filename = &amp;quot;#####&amp;quot;; // CSV file name
    var folder = &amp;quot;#####&amp;quot;; // Folder ID

    var csv = &amp;quot;&amp;quot;;
    var v = SpreadsheetApp // Now spreadsheet is an active sheet.
            .getActiveSpreadsheet()
            .getActiveSheet()
            .getDataRange()
            .getValues();
    v.forEach(function(e) {
      csv += e.join(&amp;quot;,&amp;quot;) + &amp;quot;\n&amp;quot;;
    });
    var url = DriveApp.getFolderById(folder)
              .createFile(filename, csv, MimeType.CSV)
              .getDownloadUrl()
              .replace(&amp;quot;?e=download&amp;amp;gd=true&amp;quot;,&amp;quot;&amp;quot;);
    return url;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Making charts at spreadsheet</title>
      <link>https://tanaikech.github.io/2017/02/13/making-charts-at-spreadsheet</link>
      <pubDate>Mon, 13 Feb 2017 08:57:58 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/02/13/making-charts-at-spreadsheet</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://tanaikech.github.io/img/table.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var ss = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
 var chart = sheet.newChart()
    .setChartType(Charts.ChartType.LINE)
    .asLineChart()
    .addRange(sheet.getRange(&#39;a1:a21&#39;))
    .addRange(sheet.getRange(&#39;b1:b21&#39;))
    .addRange(sheet.getRange(&#39;c1:c21&#39;))
    .setColors([&amp;quot;green&amp;quot;, &amp;quot;red&amp;quot;])
    .setBackgroundColor(&amp;quot;black&amp;quot;)
    .setPosition(5, 5, 0, 0)
    .setPointStyle(Charts.PointStyle.MEDIUM)
    .setOption(&#39;useFirstColumnAsDomain&#39;, true)
    .setOption(&#39;height&#39;, 280)
    .setOption(&#39;width&#39;, 480)
    .setOption(&#39;title&#39;, &#39;Sample chart&#39;)
    .setOption(&#39;hAxis&#39;, {
      title: &#39;x axis&#39;,
      minValue: 0,
      maxValue: 20,
      titleTextStyle: {
        color: &#39;#c0c0c0&#39;,
        fontSize: 20,
        italic: false,
        bold: false
      },
      textStyle: {
        color: &#39;#c0c0c0&#39;,
        fontSize: 12,
        bold: false,
        italic: false
      },
      baselineColor: &#39;#c0c0c0&#39;,
      gridlines: {
        color: &#39;#c0c0c0&#39;,
        count: 4
      }
    })
    .setOption(&#39;vAxis&#39;, {title: &#39;y axis&#39;,
      minValue: 0,
      maxValue: 800,
      titleTextStyle: {
        color: &#39;#c0c0c0&#39;,
        fontSize: 20,
        italic: false,
        bold: false
      },
      textStyle: {
        color: &#39;#c0c0c0&#39;,
        fontSize: 12,
        bold: false,
        italic: false
      },
      baselineColor: &#39;#c0c0c0&#39;,
        gridlines: {
        color: &#39;#c0c0c0&#39;,
        count: 4
      }
    })
    .setOption(&#39;legend&#39;, {
      position: &#39;right&#39;,
      textStyle: {
        color: &#39;yellow&#39;,
        fontSize: 16
      }
    })
    .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://tanaikech.github.io/img/chart.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Reference pages are &lt;a href=&#34;https://developers.google.com/apps-script/reference/spreadsheet/embedded-line-chart-builder&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://developers.google.com/chart/interactive/docs/gallery/areachart#configuration-options&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>File Upload and Download with File Convert For curl using Drive API</title>
      <link>https://tanaikech.github.io/2017/02/08/file-upload-and-download-with-file-convert-for-curl-using-drive-api</link>
      <pubDate>Wed, 08 Feb 2017 15:50:52 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/02/08/file-upload-and-download-with-file-convert-for-curl-using-drive-api</guid>
      <description>

&lt;p&gt;It is necessary to retrieve access token on Google. Scope is as follows.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://www.googleapis.com/auth/drive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other mimetypes can be seen &lt;a href=&#34;https://developers.google.com/drive/v3/web/manage-downloads&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;download-and-convert-from-spreadsheet-to-excel&#34;&gt;Download and convert from Spreadsheet to Excel&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;curl -X GET -sSL \
        -H &amp;quot;Authorization: Bearer [Your access token]&amp;quot; \
        -o &amp;quot;Excel file name&amp;quot; \
        &amp;quot;https://www.googleapis.com/drive/v3/files/[File ID]/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;upload-and-convert-from-excel-to-spreadsheet&#34;&gt;Upload and convert from Excel to Spreadsheet&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST -sSL \
        -H &amp;quot;Authorization: Bearer [Your access token]&amp;quot; \
        -F &amp;quot;metadata={ \
                     name : &#39;[File name on Google Drive]&#39;, \
                     mimeType : &#39;application/vnd.google-apps.spreadsheet&#39; \
                     };type=application/json;charset=UTF-8&amp;quot; \
        -F &amp;quot;file=@[Your Excel file];type=application/vnd.ms-excel&amp;quot; \
        &amp;quot;https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sample Array Script for Spreadsheet</title>
      <link>https://tanaikech.github.io/2017/02/08/sample-array-script-for-spreadsheet</link>
      <pubDate>Wed, 08 Feb 2017 08:50:38 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/02/08/sample-array-script-for-spreadsheet</guid>
      <description>&lt;p&gt;This is a Sample Array Script for Spreadsheet. It makes an 2D array filled by strings and number. The strings and number are column strings and row number, respectively.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;However, because this is a sample, the maximum column number is 26.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function sa(row, col){
  if (col &amp;gt; 26) return;

  var ar = new Array(row);
  for(var i = 0; i &amp;lt; row; i++) ar[i] = new Array(col);
  for (var i = 0; i &amp;lt; row; i++){
    for (var j = 0; j &amp;lt; col; j++){
      ar[i][j] = String.fromCharCode(i + 97) + String(j + 1);
    }
  }
  return ar.map(function(x, i){return x.map(function(y, j){return ar[j][i]})});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &amp;ldquo;sa(10,10)&amp;rdquo; is given, following array can be output.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
    [a1, b1, c1, d1, e1, f1, g1, h1, i1, j1],
    [a2, b2, c2, d2, e2, f2, g2, h2, i2, j2],
    [a3, b3, c3, d3, e3, f3, g3, h3, i3, j3],
    [a4, b4, c4, d4, e4, f4, g4, h4, i4, j4],
    [a5, b5, c5, d5, e5, f5, g5, h5, i5, j5],
    [a6, b6, c6, d6, e6, f6, g6, h6, i6, j6],
    [a7, b7, c7, d7, e7, f7, g7, h7, i7, j7],
    [a8, b8, c8, d8, e8, f8, g8, h8, i8, j8],
    [a9, b9, c9, d9, e9, f9, g9, h9, i9, j9],
    [a10, b10, c10, d10, e10, f10, g10, h10, i10, j10]
]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Event of onEdit() for Google spreadsheet</title>
      <link>https://tanaikech.github.io/2017/02/07/event-of-onedit-for-google-spreadsheet</link>
      <pubDate>Tue, 07 Feb 2017 11:03:56 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/02/07/event-of-onedit-for-google-spreadsheet</guid>
      <description>

&lt;h1 id=&#34;about-event-objects&#34;&gt;About Event Objects&lt;/h1&gt;

&lt;p&gt;For example, it thinks the situation of input text of &amp;lsquo;test&amp;rsquo; to &amp;lsquo;A1&amp;rsquo; on a sheet.&lt;/p&gt;

&lt;p&gt;When you use only &amp;lsquo;onEdit(e)&amp;rsquo; without an installing trigger, &amp;lsquo;e&amp;rsquo; has following parameters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{authMode=LIMITED, range=Range, source=Spreadsheet, user=, value=test}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the event cannot send an e-mail because of &amp;lsquo;authMode=LIMITED&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;When you use &amp;ldquo;onEdit(e)&amp;rdquo; with an installing trigger of &amp;ldquo;Edit&amp;rdquo;, &amp;lsquo;e&amp;rsquo; has following parameters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{authMode=FULL, range=Range, source=Spreadsheet, value=test, triggerUid=#####}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the event can send an e-mail because of &amp;lsquo;authMode=FULL&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;&amp;lsquo;range&amp;rsquo; and &amp;lsquo;source&amp;rsquo; are the coordinate and spreadsheet of the edited cell, respectively. They can confirm using &amp;lsquo;e.range.getA1Notation()&amp;rsquo; and &amp;lsquo;getId()&amp;rsquo;, respectively.&lt;/p&gt;

&lt;h2 id=&#34;about-ljava-lang-object&#34;&gt;About [Ljava.lang.Object;&lt;/h2&gt;

&lt;p&gt;About &amp;ldquo;Form submit event&amp;rdquo; of GAS with spreadsheet, e.values and e.namedValues have &amp;ldquo;[Ljava.lang.Object;&amp;ldquo;. Using &amp;ldquo;JSON.Stringify()&amp;rdquo; like &amp;ldquo;JSON.stringify(e.values)&amp;rdquo;, &amp;ldquo;JSON.stringify(e.namedValues)&amp;rdquo;, values from &amp;ldquo;[Ljava.lang.Object;&amp;rdquo; can be retrieved.&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;p&gt;You can see the detailed information of sheet events from &lt;a href=&#34;https://developers.google.com/apps-script/guides/triggers/events&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>File upload using doPost on Google Web Apps</title>
      <link>https://tanaikech.github.io/2017/02/05/file-upload-using-dopost-on-google-web-apps</link>
      <pubDate>Sun, 05 Feb 2017 11:40:08 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/02/05/file-upload-using-dopost-on-google-web-apps</guid>
      <description>

&lt;h1 id=&#34;file-upload-using-html-form-in-gas-project&#34;&gt;File upload using HTML form in GAS project&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Rule&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Following scripts have to be made into a project of Google Apps Script.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Deploy the GAS project as a web application. &lt;a href=&#34;https://developers.google.com/apps-script/guides/web&#34;&gt;Ref&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After updated the script, it has to be updated as a new version.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Form.html :&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;form&amp;gt;
      &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;imageFile&amp;quot;&amp;gt;
      &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;ok&amp;quot; onclick=&amp;quot;google.script.run.upload(this.parentNode)&amp;quot;&amp;gt;
    &amp;lt;/form&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;GAS :&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function doGet() {
  return HtmlService.createHtmlOutputFromFile(&#39;Form.html&#39;);
}

function upload(e) {
  var destination_id = &#39;#####&#39;; // Folder ID of destination folder

  // Reference : https://developers.google.com/apps-script/reference/base/blob#getAs(String)
  // You can use &#39;application/pdf&#39;, &#39;image/bmp&#39;, &#39;image/gif&#39;, &#39;image/jpeg&#39; and &#39;image/png&#39;.
  var contentType = &#39;image/jpeg&#39;;
  var img = e.imageFile;

  var destination = DriveApp.getFolderById(destination_id);
  var img = img.getAs(contentType);
  destination.createFile(img);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you set &amp;lsquo;image/jpeg&amp;rsquo; as &amp;ldquo;contentType&amp;rdquo; and upload png file, the uploaded image file is converted to jpeg file and saved it to the destination folder.&lt;/p&gt;

&lt;h1 id=&#34;file-upload-from-local-pc&#34;&gt;File upload from local PC&lt;/h1&gt;

&lt;p&gt;For the Web API of Google HTML service, cannot &amp;ldquo;multipart/form-data&amp;rdquo; be used from local HTML form? Although I investigated it and tried various methods of file upload using &amp;ldquo;multipart/form-data&amp;rdquo;, all of them didn&amp;rsquo;t work. So I thought other method which is file upload without &amp;ldquo;multipart/form-data&amp;rdquo;. Of course, if you use Drive API, file upload can be easily done. But I wanted to achieve the file upload using Web API of Google HTML service. I think that this is self-satisfaction.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rule&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Following GAS has to be made into a project of Google Apps Script.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Deploy the GAS project as a web application. &lt;a href=&#34;https://developers.google.com/apps-script/guides/web&#34;&gt;Ref&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After updated the script, it has to be updated as a new version.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;GAS :&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This script is very simple sample. It uploads image files of bmp, gif, jpeg, png and svg. When you want to upload other files, please change following script.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function doGet(e) {
  return message(&amp;quot;Error: no parameters&amp;quot;);
}

function doPost(e) {
  if (!e.parameters.filename || !e.parameters.file || !e.parameters.imageformat) {
    return message(&amp;quot;Error: Bad parameters&amp;quot;);
  } else {
    var imgf = e.parameters.imageformat[0].toUpperCase();
    var mime =
        (imgf == &#39;BMP&#39;)  ? MimeType.BMP
      : (imgf == &#39;GIF&#39;)  ? MimeType.GIF
      : (imgf == &#39;JPEG&#39;) ? MimeType.JPEG
      : (imgf == &#39;PNG&#39;)  ? MimeType.PNG
      : (imgf == &#39;SVG&#39;)  ? MimeType.SVG
      : false;
    if (mime) {
      var data = Utilities.base64Decode(e.parameters.file, Utilities.Charset.UTF_8);
      var blob = Utilities.newBlob(data, mime, e.parameters.filename);
      DriveApp.getFolderById(&#39;FOLDER ID&#39;).createFile(blob);
      return message(&amp;quot;completed&amp;quot;);
    } else {
      return message(&amp;quot;Error: Bad image format&amp;quot;);
    }
  }
}

function message(msg) {
  return ContentService.createTextOutput(JSON.stringify({result: msg})).setMimeType(ContentService.MimeType.JSON);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;curl :&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -L \
    -F &#39;filename=[file name on Google Drive]&#39; \
    -F &#39;imageformat=[image format (bmp, gif, jpeg, png and svg)]&#39; \
    -F &amp;quot;file=`base64 [upload file]`&amp;quot; \
    &#39;[Current web app URL (https://script.google.com/macros/s/[Project ID]/exec)]&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &amp;ldquo;doPost&amp;rdquo; of &lt;a href=&#34;https://developers.google.com/apps-script/guides/web&#34;&gt;Google Web Apps&lt;/a&gt;, files cannot be uploaded from local PC, while text data which isn&amp;rsquo;t a file can be uploaded. So I thought that it converted from image data to base64 data, and upload it. By this, it was found that various files can be uploaded from local HTML form using &amp;ldquo;doPost&amp;rdquo; of Google Web Apps.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;html form :&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;http://code.jquery.com/jquery-latest.js&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;file&amp;quot;&amp;gt;

    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        $(function(){
            var url = &#39;https://script.google.com/macros/s/[Project ID]/exec&#39;;
            var params = {
                filename: &#39;samplefile&#39;,
                imageformat: &#39;PNG&#39;
            };

            $(&#39;#file&#39;).on(&amp;quot;change&amp;quot;, function() {
                var file = this.files[0];
                var fr = new FileReader();
                fr.onload = function(e) {
                    params.file = e.target.result.replace(/^.*,/, &#39;&#39;);
                    postJump();
                }
                fr.readAsDataURL(file);
            });

            function postJump(){
                var html = &#39;&amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;&#39;+url+&#39;&amp;quot; id=&amp;quot;postjump&amp;quot; style=&amp;quot;display: none;&amp;quot;&amp;gt;&#39;;
                Object.keys(params).forEach(function (key) {
                    html += &#39;&amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;&#39;+key+&#39;&amp;quot; value=&amp;quot;&#39;+params[key]+&#39;&amp;quot; &amp;gt;&#39;;
                });
                html += &#39;&amp;lt;/form&amp;gt;&#39;;
                $(&amp;quot;body&amp;quot;).append(html);
                $(&#39;#postjump&#39;).submit();
                $(&#39;#postjump&#39;).remove();
            }
        });
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Add next row to current row using AWK</title>
      <link>https://tanaikech.github.io/2017/02/05/add-next-row-to-current-row-using-awk</link>
      <pubDate>Sun, 05 Feb 2017 11:03:30 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/02/05/add-next-row-to-current-row-using-awk</guid>
      <description>&lt;p&gt;&lt;strong&gt;File.txt :&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1
a2
a3
a4
a5
a6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Code :&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;awk &#39;{array[NR]=$0} END {for (i in array) {if (i&amp;gt;1) {{print array[i-1]&amp;quot;,&amp;quot;array[i]}}}}&#39; File.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Result :&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1,a2
a2,a3
a3,a4
a4,a5
a5,a6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the all rows are imported to an array, it shows next row to current row under a condition of row &amp;gt; 1.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Retrieving cells without blank using GAS</title>
      <link>https://tanaikech.github.io/2017/02/03/retrieving-cells-without-blank-using-gas</link>
      <pubDate>Fri, 03 Feb 2017 10:14:25 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/02/03/retrieving-cells-without-blank-using-gas</guid>
      <description>

&lt;p&gt;This is a sample script for retrieving cells without blank cells. Figure 1 shows the sample spreadsheet. In this sheet, &lt;u&gt;the row 14 has one space.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/fig170203a.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 1: Sample spreadsheet.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Data is retrieved as follows.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var data = SpreadsheetApp
             .getActiveSpreadsheet()
             .getActiveSheet()
             .getRange(&#39;a1:a30&#39;)
             .getValues();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-retrieving-cells-with-spaces-and-no-blank-cells&#34;&gt;1. Retrieving cells with spaces and no blank cells.&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  var Result = [i for each (i in data)if (i)].join(&#39;&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Result : Hello World&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-retrieving-cells-without-both-spaces-and-blank-cells&#34;&gt;2. Retrieving cells without both spaces and blank cells.&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  var Result = [i for each (i in data)if (isNaN(i))].join(&#39;&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Result : HelloWorld&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>One Liner Code for Netatmo</title>
      <link>https://tanaikech.github.io/2017/01/11/one-liner-code-for-netatmo</link>
      <pubDate>Wed, 11 Jan 2017 15:00:01 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/01/11/one-liner-code-for-netatmo</guid>
      <description>

&lt;p&gt;I made One Liner Code to retrieve data using Netatmo API. There are 2 ways. One is for windows dos. Another is for unix bash. Requirement tools are curl and jq.&lt;/p&gt;

&lt;h3 id=&#34;windows-dos&#34;&gt;windows dos&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; setlocal &amp;amp; curl -s -d &amp;quot;grant_type=password&amp;amp;client_id=&#39;#####&#39;&amp;amp;client_secret=&#39;#####&#39;&amp;amp;username=&#39;#####&#39;&amp;amp;password=&#39;#####&#39;&amp;amp;scope=read_station&amp;quot; &amp;quot;https://api.netatmo.net/oauth2/token&amp;quot; | for /f &amp;quot;usebackq tokens=*&amp;quot; %a in (`jq -r &amp;quot;.access_token&amp;quot;`) do @set a=&amp;quot;%a&amp;quot; | curl -s -d &amp;quot;access_token=%a&amp;amp;device_id=&#39;#####&#39;&amp;quot; &amp;quot;https://api.netatmo.net/api/getstationsdata&amp;quot; &amp;gt; dat.txt &amp;amp; for /f &amp;quot;usebackq tokens=*&amp;quot; %b in (`jq -r &amp;quot;.body.devices[0].dashboard_data.Temperature&amp;quot; dat.txt`) do @set b=&amp;quot;%b&amp;quot; | echo: &amp;amp; set /p nb=Indoor: Temperature %b [degree C],&amp;lt;nul &amp;amp; for /f &amp;quot;usebackq tokens=*&amp;quot; %b in (`jq -r &amp;quot;.body.devices[0].dashboard_data.Humidity&amp;quot; dat.txt`) do @set b=&amp;quot;%b&amp;quot; | set /p nb=Humidity %b [%],&amp;lt;nul &amp;amp; for /f &amp;quot;usebackq tokens=*&amp;quot; %b in (`jq -r &amp;quot;.body.devices[0].dashboard_data.Pressure&amp;quot; dat.txt`) do @set b=&amp;quot;%b&amp;quot; | set /p nb=Pressure %b [hPa]&amp;lt;nul &amp;amp; for /f &amp;quot;usebackq tokens=*&amp;quot; %b in (`jq -r &amp;quot;.body.devices[0].modules[0].dashboard_data.Temperature&amp;quot; dat.txt`) do @set b=&amp;quot;%b&amp;quot; | echo: &amp;amp; set /p nb=Outdoor: Temperature %b [degree C],&amp;lt;nul &amp;amp; for /f &amp;quot;usebackq tokens=*&amp;quot; %b in (`jq -r &amp;quot;.body.devices[0].modules[0].dashboard_data.Humidity&amp;quot; dat.txt`) do @set b=&amp;quot;%b&amp;quot; | set /p nb=Humidity %b [%]&amp;lt;nul &amp;amp; del dat.txt

Indoor: Temperature 12 [degree C],  Humidity 56 [%],  Pressure 1000.2 [hPa]
Outdoor: Temperature 12.3 [degree C],  Humidity 56 [%]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unix-bash&#34;&gt;unix bash&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s -d &amp;quot;grant_type=password&amp;amp;client_id=&#39;#####&#39;&amp;amp;client_secret=&#39;#####&#39;&amp;amp;username=&#39;#####&#39;&amp;amp;password=&#39;#####&#39;&amp;amp;scope=read_station&amp;quot; &amp;quot;https://api.netatmo.net/oauth2/token&amp;quot;|curl -s -d &amp;quot;access_token=`jq -r &#39;.access_token&#39;`&amp;amp;device_id=&#39;#####&#39;&amp;quot; &amp;quot;https://api.netatmo.net/api/getstationsdata&amp;quot;|jq -r &#39;&amp;quot;\nIndoor: Temperature &amp;quot;+(.body.devices[0].dashboard_data.Temperature|tostring)+&amp;quot; [degree C], Humidity &amp;quot;+(.body.devices[0].dashboard_data.Humidity|tostring)+&amp;quot; [%], Pressure &amp;quot;+(.body.devices[0].dashboard_data.Pressure|tostring)+&amp;quot; [hPa]\nOutdoor: Temperature &amp;quot;+(.body.devices[0].modules[0].dashboard_data.Temperature|tostring)+&amp;quot; [degree C], Humidity &amp;quot;+(.body.devices[0].modules[0].dashboard_data.Humidity|tostring)+&amp;quot; [%]&amp;quot;&#39;

Indoor: Temperature 12 [degree C], Humidity 56 [%], Pressure 1000.2 [hPa]
Outdoor: Temperature 12.3 [degree C], Humidity 56 [%]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to use these One Liner Codes, you can use following code. Please replace &amp;ldquo;#####&amp;rdquo; to yours.&lt;/p&gt;

&lt;p&gt;Also you can see the detailed information at &lt;a href=&#34;https://github.com/tanaikech/cui4netatmo&#34;&gt;https://github.com/tanaikech/cui4netatmo&lt;/a&gt;. You will see 2 scripts except for one-liner code. These scripts retrieve data from netatmo using refresh token.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Library for python</title>
      <link>https://tanaikech.github.io/2016/10/30/library-for-python</link>
      <pubDate>Sun, 30 Oct 2016 13:38:29 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2016/10/30/library-for-python</guid>
      <description>&lt;p&gt;This &amp;ldquo;souwapy&amp;rdquo; is a library for summing array elements with high speed by new algorithm (&lt;a href=&#34;https://tanaikech.github.io/2016/10/13/improved-algorithms-for-summation-of-array-elements/&#34;&gt;Pyramid method&lt;/a&gt;). The speed is faster than csv and panbdas module of python and v8 engine of node.js. The souwapy module is 2.3 and 3.1 times faster than csv and pandas module, respectively. This was really surprised me. It was found that the theory was correct.&lt;/p&gt;

&lt;p&gt;At first, I have created this theory for Google Apps Script. But recently I had to use large data and output a csv file on python. So I made this library. Additionally, I had wanted to know how to public own library to PyPI before. This chance was good for me. If this library is helpful for other people, I&amp;rsquo;m glad.&lt;/p&gt;

&lt;p&gt;The detailed information of souwapy is as follows. You can know how to install and use this library.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;PyPI &amp;ndash;&amp;gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://pypi.python.org/pypi/souwapy&#34;&gt;https://pypi.python.org/pypi/souwapy&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;GitHub &amp;ndash;&amp;gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/tanaikech/souwapy&#34;&gt;https://github.com/tanaikech/souwapy&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Element&#39;s Duplicate Number in Array at Python</title>
      <link>https://tanaikech.github.io/2016/10/21/elements-duplicate-number-in-array-at-python</link>
      <pubDate>Fri, 21 Oct 2016 12:29:25 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2016/10/21/elements-duplicate-number-in-array-at-python</guid>
      <description>&lt;p&gt;Suddenly I had to need this.&lt;/p&gt;

&lt;p&gt;This script can get the duplicate number of each element in array at Python. In this script, the duplicate number of each element is obtained and sorted by the duplicate number. This was expressed by the comprehension.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;b&#39;]
result = sorted({i: data.count(i) for i in set(data)}.items(), key=lambda x: x[1], reverse=True)
print(result)

&amp;gt;&amp;gt;&amp;gt; [(&#39;b&#39;, 4), (&#39;c&#39;, 3), (&#39;d&#39;, 2), (&#39;a&#39;, 1)]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CoffeeScript</title>
      <link>https://tanaikech.github.io/2016/10/20/coffeescript</link>
      <pubDate>Thu, 20 Oct 2016 14:34:59 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2016/10/20/coffeescript</guid>
      <description>&lt;p&gt;I may be slow a bit, but I could notice much convenience of CoffeeScript just now. I didn&amp;rsquo;t know that scripts of GAS can be made by CoffeeScript up until now. This will have me work more effectively! :D&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Effects on Optimized Codes of Pyramid Method</title>
      <link>https://tanaikech.github.io/2016/10/13/effects-on-optimized-codes-of-pyramid-method</link>
      <pubDate>Thu, 13 Oct 2016 15:57:20 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2016/10/13/effects-on-optimized-codes-of-pyramid-method</guid>
      <description>

&lt;p&gt;&lt;center&gt;
Kanshi TANAIKE
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;#ref1&#34;&gt;I have already reported that the pyramid method is one of very effectively algolithms for summing string elements in an array using Google Apps Script (GAS).&lt;/a&gt; This report describes the adaptability of the pyramid method to any languages except for GAS. c++ (g++), Go, Java, Javascript on Node.js, Python and Ruby were chosen as the sample languages. In those languages, there are languages which have the distinctive commands for summing the array elements. In this report, &amp;ldquo;+&amp;rdquo; operator as a standard command and a special command for each language were used. For c++ (g++), Javascript on Node.js and Python which have no distinctive commands for summing the array elements, only &amp;ldquo;+&amp;rdquo; operator was used. For others, both &amp;ldquo;+&amp;rdquo; operator and each special command such as &amp;ldquo;[]byte&amp;rdquo;, &amp;ldquo;StringBuilder&amp;rdquo; and &amp;ldquo;&amp;lt;&amp;lt;&amp;rdquo; were used. For languages without the distinctive commands for summing, the pyramid method made us show some interesting phenomena. It was found that the pyramid method shows a good effect on only the specific language. It was found that &amp;ldquo;+&amp;rdquo; operator had been optimized for g++ and Node.js. &amp;ldquo;+&amp;rdquo; operator of Python was corresponding to theoretical results. This means that &amp;ldquo;+&amp;rdquo; operator of Python is not optimized. On the other hand, for languages with the distinctive commands for summing, it was found that the distinctive commands is incompatible to the pyramid method. These results made us show the possibility of visualization for the optimized codes.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;When the string elements in an array are summed by a script, there are various patterns for each language. A standard algorithm is the method using &amp;ldquo;+&amp;rdquo; operator as following a pseudo code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Declare a string variable arr, sum
    Declare an integer variable loopcounter
    Set arr to size n
    for loopcounter = 0 to (size of arr) - 1
        sum = sum + arr[loopcounter]
        loopcounter = loopcounter + 1
    endfor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some languages have the special commands (&amp;rdquo;[]byte&amp;rdquo;, &amp;ldquo;StringBuilder&amp;rdquo; and &amp;ldquo;&amp;lt;&amp;lt;&amp;ldquo;) for summing string elements except for &amp;ldquo;+&amp;rdquo; operator. Such languages can sum elements effectively using the special commands even if the standard method was used. However the languages which have no special commands must use only &amp;ldquo;+&amp;rdquo; operator. I had experienced that at GAS. Therefore, I have proposed the pyramid method. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;] It had been found that the pyramid method is high efficiency for summing the array elements at GAS. It is very important for today, which have increased the opportunity to handle the strings, to efficiently sum the strings. In this report, I have investigated about the adaptability of pyramid method to any languages.&lt;/p&gt;

&lt;p&gt;Now I have 2 patterns of the standard method and the pyramid method for summing array elements. Furthermore, those 2 patterns were demonstrated by experimental and theoretical approaches. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;] I have thought that the optimization of each language may be able to be evaluated using as those tools. In this study, those tools made us show some interesting phenomena. The pyramid method showed a good effect on only the specific language using &amp;ldquo;+&amp;rdquo; operator. It was found that the languages which showed no good effect had had the optimized &amp;ldquo;+&amp;rdquo; operator. It is considered that this is due to the optimization engine of interpreters and compilers. It was found that the languages with the special commands for summing array elements are incompatible to the pyramid method. These results say that the languages with &amp;ldquo;+&amp;rdquo; operator without the optimization can benefit from the pyramid method. Also it is considered that the pyramid method can be used to evaluate the optimization engine. The result in this study gave us the possibility of visualization for optimized codes. So there are two aims of this report. One is to confirm the effects on various languages of the pyramid methods. And another is to consider the visualization of optimization engine.&lt;/p&gt;

&lt;p&gt;For the detailed information of the standard method and the pyramid method which are used in this report, you can see them. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;experimental-procedure&#34;&gt;Experimental procedure&lt;/h2&gt;

&lt;p&gt;$\Psi, \mu, \theta, \phi$ and $\omega$ which are used in this report are the total amount of active data during the summing process, the size of one array-element, the number of total array elements, the size of division for dividing array and the number of divisions for the pyramid method, respectively. The detailed information of them are &lt;a href=&#34;#ref1&#34;&gt;here&lt;/a&gt;. The array used in this study is 2 dimensional array constructed with strings such as [[&amp;lsquo;0000000&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], [&amp;lsquo;0000001&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], [&amp;lsquo;0000002&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], ,,,]. When this array is summed, &amp;lsquo;,&amp;rsquo; and &amp;lsquo;\n&amp;rsquo; are added as a delimiter and an end code, respectively. So the size of an element $\mu$ becomes 10 bytes. The optimized $\omega$ and $\phi$ were obtained by report [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;]. Those are $\omega=\log_{10} \theta - 1, \phi=(1/\theta)^{-1/(\omega+1)}$. The languages which were chosen for this study are shown in table 1. c++ sources were compiled by g++ (6.1.0 on msys2) with the option &amp;ldquo;-O2&amp;rdquo;. The PC spec which was used for measuring data in this study is CPU Core i5-3210M, Memory 8 GB, OS Windows10 (x64) (v1607).&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Table 1: Languages used in this study.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Language&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c++&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;Compiler g++ (6.1.0 on msys2)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Go&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v1.7.1 windows/amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v8 (1.8.0_101)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Javascript on Node.js&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v6.3.0 (v8 &amp;lsquo;5.0.71.52&amp;rsquo;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Python&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v3.5.2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Ruby&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v2.3.1p112&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;results-and-discussions&#34;&gt;Results and discussions&lt;/h2&gt;

&lt;p&gt;Figures 1 - 6 show the behavior of the processing time for each language with the increase in $\theta$ which is the number of array elements. All figures were put in a table. Left side shows the results taken from the measurements using &amp;ldquo;+&amp;rdquo; operator. Right side shows the results taken from the measurements using the distinctive commands of each language.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/gpp1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 1: g++ using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/node1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 2: Javascript on Node.js using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/py1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 3: Python using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/go1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/go2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 4(a): Go using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 4(b): Go using &amp;ldquo;[]byte&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/go2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 4(c): Go using &amp;ldquo;[]byte&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/java1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/java2.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 5(a): Java using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 5(b): Java using &amp;ldquo;StringBuilder&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/ruby1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/ruby2.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 6(a): Ruby using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 6(b): Ruby using &amp;ldquo;&amp;lt;&amp;lt;&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;g++, Node.js and Python in Figs. 1 - 3 have no distinctive commands except for &amp;ldquo;+&amp;rdquo; operator. Go, Java and Ruby in Figs. 4 - 6 have distinctive commands. For the results of &amp;ldquo;+&amp;rdquo; operator, the language except for g++ and Node.js can be confirmed the effect of the pyramid method. Especially, Python and Ruby in Figs. 3 and 6(a) show the behavior corresponding to theoretical results which had been already reported by me. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;] For the standard method, $\Psi$, which is the total amount of active data during summing, increases proportionally to the square of $\theta$. For the pyramid method, $\Psi$ linearly increases with the increase in $\theta$. Go and Java in Figs. 4(a) and 5(a) show the increase of $\Psi$ proportionally to the square of $\theta$ for both red and blue lines. The optimization may influence to the process of pyramid method. g++ and Node.js in Figs. 1 and 2 show no effect of the pyramid method. It is considered that &amp;ldquo;+&amp;rdquo; operator is optimized for g++ and Node.js which have no special commands for summing array elements. V8 engine of Node.js is known as one of the optimization engines. The optimization may influence to only the standard method or disturb the work of pyramid method. For Go, Java and Ruby which have the special commands for summing, the pyramid method shows no effect as shown in Figs. 4(b), 4(c), 5(b) and 6(b). Also it is considered that this is due to the optimization. In Figs. 1, 2, 4(b), 5(b) and 6(b), $\Psi$ linearly increases with the increase in $\theta$ for the standard method. Furthermore, the reverse phenomenon that the process speed of standard method becomes faster than that of pyramid method occurs in those figures. These clearly show the optimization of summing process. In order to consider these, it thinks of the number of loops during summing process. The number of loops $N_{l}$ during summing process can be expressed as follows.&lt;/p&gt;

&lt;p&gt;\[ N_{l} = \sum_{k=1}^{\omega - 1} \frac{\theta}{\phi^{k}} \tag{1} \]&lt;/p&gt;

&lt;p&gt;From Eq. (1), $N_{l0} = \theta$ at $\omega=0$ and $N_{li} = \theta(1 - \phi^{-1})^{-1}$ at $\omega=\infty$ can be obtained. Therefore, the increasing rate $\varepsilon$ from $N_{l0}$ to $N_{li}$ becomes as follows.&lt;/p&gt;

&lt;p&gt;\[ \varepsilon = 100 \times \frac{1}{(\phi - 1)} \tag{2} \]&lt;/p&gt;

&lt;p&gt;where the unit is $\%$. $\omega = 0$ and $\omega \geqq 1$ mean the standard and the pyramid method, respectively. Here, since this study was performed under the condition of $\theta = 1,000,000$ and $\phi = 10$, $\varepsilon$ is $11\%$ and the number of loops of the pyramid method increases 11,000 for that of the standard method under this condition. In this study, the number of loops for the pyramid method is $11\%$ larger than that of the standard method. Then, I think that when the languages for summing process are optimized, the search of last address of each string is much faster than that of languages without the optimization. By these, when the languages have the special commands for summing array elements and the optimized &amp;ldquo;+&amp;rdquo; operator, it is considered that the processing time strongly depends on the number of loops in the code rather than $\Psi$. Therefore, it is considered that the reverse phenomenon occurs for the processing time between the standard and the pyramid method as shown in Figs. 1, 2, 5(b) and 6(b). And the reverse phenomenon is remarkable, since the speed of g++ is much faster than that of other languages.&lt;/p&gt;

&lt;p&gt;Here, when Figs. 2 and 6(b) are compared, it is found that both behaviors of $\Psi$ for the increase in $\theta$ are almost the same. At $\theta = 1,000,000$ of the standard method, the processing time is 1.13 s and 1.25 s for Node.js and Ruby, respectively. It may indicate that both optimization is almost the same.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/rank.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 7: Top 10 data of processing time for each language at $\theta = 1,000,000$.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Figure 7 shows the summing process-time for each language at $\theta = 1,000,000$. The top 10 data are shown in Fig. 7. This figure shows the high performance of languages (g++, Go and Java) compiled by the compiler. There is two interesting points. 1st point is the result of Python using the pyramid method. Python using the pyramid method shows 2 times faster in the processing speed than Node.js with V8 engine. When it thinks that the processing time of Python using the standard method at $\theta = 1,000,000$ is 6.1 s, this is the remarkable data for the pyramid method. And for $\theta = 5,000,000$, the processing speed of Python is 2.6 times faster than that of Node.js. In the 2nd point, for Go and Ruby, it was found that &amp;ldquo;[]byte&amp;rdquo; and &amp;ldquo;&amp;lt;&amp;lt;&amp;rdquo; are predominantly optimized compared to &amp;ldquo;+&amp;rdquo; operator.&lt;/p&gt;

&lt;p&gt;From the results in this study, it was found that the pyramid method is efficient for languages except for GAS. Especially, languages corresponding to the trend of theoretical results are more efficiently. Languages, which have distinctive optimized commands for summing array elements, should use both the special commands and the standard method. Languages which needs to compile should use the standard method. These results can also be used to the visualization of optimization engine.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Following results could be obtained in this study.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The pyramid method for summing array elements is efficient for the languages except for GAS.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Languages with &amp;ldquo;+&amp;rdquo; operator without the optimization can benefit from the pyramid method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Languages, which have distinctive optimized commands for summing array elements, should use both the special commands and the standard method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The pyramid method can be used to evaluate the optimization engine.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The result in this study gave us the possibility of visualization for optimized codes.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://tanaikech.github.io/2016/10/13/improved-algorithms-for-summation-of-array-elements&#34;&gt;&amp;ldquo;Improved Algorithms for Summation of Array Elements&amp;rdquo;, October 13, 2016&lt;/a&gt;
&lt;a name=&#34;ref1&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;appendix&#34;&gt;Appendix&lt;/h2&gt;

&lt;p&gt;Scripts used at this report are &lt;a href=&#34;https://github.com/tanaikech/SOUWA_test_scripts&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Improved Algorithms for Summation of Array Elements</title>
      <link>https://tanaikech.github.io/2016/10/13/improved-algorithms-for-summation-of-array-elements</link>
      <pubDate>Thu, 13 Oct 2016 14:39:34 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2016/10/13/improved-algorithms-for-summation-of-array-elements</guid>
      <description>

&lt;p&gt;&lt;center&gt;
Kanshi TANAIKE
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;I considered an efficient algorithm for summation of array elements. All elements in an array are string. When those elements are summed using scripts, a standard method is to add each element in order. If the script is run without any optimize, the process becomes gradually sluggish, because the total amount of active data during the summation process is proportional to the square of the number of array elements. This leads directly to the high process-cost. Such phenomenon notably appears at Google Apps Script (GAS). This report says about the solution of this problem using a new algorithm of a pyramid method. The pyramid method achieves that the total amount of active data increases proportional to the linear of the number of array elements. By this, the processing time becomes much shorter than that of the process using the standard method. The pyramid method achieved the process-cost reduction of $99.7\%$ compared with the standard method at GAS. I realized again that new discoveries are hidden into the familiar scenes of every-day life.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;What script comes to mind when you hear the summation of string elements in an array? Most people will probably imagine the method for adding each element in order as following a pseudo code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Declare a string variable arr, sum
    Declare an integer variable loopcounter
    Set arr to size n
    for loopcounter = 0 to (size of arr) - 1
        sum = sum + arr[loopcounter]
        loopcounter = loopcounter + 1
    endfor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It can be said that these are a standard algorithm. When the number of elements is small, this standard method is so useful for the summation. But when the number is large, the summation process becomes sluggish. The reason is that the total amount of active data increases proportionally to the square of the number of array elements. Namely, it means that summing array elements in order leads to high process-cost. High process-cost connects directly to large money and time loss. The summation process is used at variety situations. Recently, the array with string elements are used at the field of big data and, web technology and so on. Therefore, it is very important to design the effective summation algorithms with lower process-cost.&lt;/p&gt;

&lt;p&gt;In this report, an efficient algorithm for summing string elements in an array is introduced. The key factor for this algorithm is to change the total amount of active data during the summation process. At the standard method, the summation process of array elements makes the total amount of active data increase proportionally to the square of number of array elements. On the other hand, at the algorithm in this report, the total amount of active data linearly increases to the number of array elements. This difference is very important for reducing the process cost.&lt;/p&gt;

&lt;p&gt;The primary aim of this report is to reduce the process cost during the summation process. The secondary aim is to reduce the burden for Google when we run the summation process of array elements using Google Apps Script (GAS). GAS is one of good resources which can be used by only browser. It is important to reduce the process cost of GAS by devising. Therefore, the samples which were used in this report were made of GAS. At next section, theoretical approaches will be introduced.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;theoretical-approaches&#34;&gt;Theoretical approaches&lt;/h2&gt;

&lt;p&gt;Array element which is used in this report is string. In order to understand the pyramid method which is introduced in this report, it thinks about the total amount of active data during the summation process. When the array elements are summed by the standard method as shown in Introduce section, the total amount of active data $\Psi$ during the process is&lt;/p&gt;

&lt;p&gt;\[ \Psi = \sum_{\lambda=1}^{\theta} \mu \lambda \tag{1} \]&lt;/p&gt;

&lt;p&gt;where $\mu$ and $\theta$ are the size of one array-element and the number of array elements, respectively.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/efig1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 1: $\Psi$ vs. $\theta$ by Eq.(1).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Figure 1 shows $\Psi$ vs. $\theta$ when $\mu$ is 10 bytes. It is found that $\Psi$ increases proportionally to the square of $\theta$ as shown in Fig.1. I have thought that the processing time has to correlate to the total amount of active data $\Psi$ during the process. In order to reduce $\Psi$, I propose a pyramid method. The pyramid method calculates the sum while dividing $\theta$ to some groups as shown in Fig. 2.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/efig2.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 2: Concept of pyramid method.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;At the pyramid method, the base array without dividing is $\omega=0$ in Fig. 2. At $\omega=1$, $\theta$ is divided to groups by $\phi$ determined as a division number. The array elements in each group is summed. This flow is performed until obtaining the result. As a sample, it shows a pseudo code with the pyramid method at $\omega=1$ obtained from Fig. 2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Declare a string variable arr, tempsum, sum
    Declare an integer variable division, loopcounter1, loopcounter2
    Set arr to size n
    division = d
    for loopcounter1 = division to (size of arr) - 1
        for loopcounter2 = 0 to (size of arr) - 1
            tempsum = tempsum + arr[loopcounter2]
            loopcounter2 = loopcounter2 + 1
        endfor
        sum = sum + tempsum
        tempsum = &#39;&#39;
        loopcounter2 = loopcounter1
        loopcounter1 = loopcounter1 + division
    endfor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When this code is compared to the code at Introduction, it notices that a loop for grouping is added. The array is divided at first loop. The array elements in each group is summed at second loop. When $\omega$ increases, the loops for grouping is increased.&lt;/p&gt;

&lt;p&gt;Here, it considers $\Psi(\omega)$ for Fig. 2. $\Psi(\omega)$ can be expressed as following an equation.&lt;/p&gt;

&lt;p&gt;$ \theta_{\omega} $&lt;/p&gt;

&lt;p&gt;\[ \Psi(\omega) =
\left(\sum_{\lambda=1}^{\phi_1} \mu_{1} \lambda\right)\frac{\theta_{1}}{\phi_{1}} +
\left(\sum_{\lambda=1}^{\phi_2} \mu_{2} \lambda\right)\frac{\theta_{2}}{\phi_{2}} +
 \cdots \]&lt;/p&gt;

&lt;p&gt;\[ + \left(\sum_{\lambda=1}^{\phi_{\omega-1}} \mu_{\omega-1} \lambda\right)\frac{\theta_{\omega-1}}{\phi_{\omega-1}}\]&lt;/p&gt;

&lt;p&gt;\[ + \left\{\left(\sum_{\lambda=1}^{\phi_{\omega}} \mu_{\omega} \lambda\right)\frac{\theta_{\omega}}{\phi_{\omega}} + \sum_{\lambda=1}^{\frac{\theta_{\omega}}{\phi_{\omega}}} \mu_{\omega}\phi_{\omega}\lambda  \right\}
 \tag{2}  \]&lt;/p&gt;

&lt;p&gt;where $\phi$ is a division number. $\theta_{\omega}$ and $\mu_{\omega}$ are $ \theta\phi^{1-\omega} $ and $ \mu\phi^{\omega-1} $, respectively. Equation (2) can be expanded as follows.&lt;/p&gt;

&lt;p&gt;\[ \Psi(\phi, \omega) = \frac{\mu\theta}{2}\left\{ \left(\phi + 3\right)\omega + \frac{\theta}{\phi^{\omega}} - 1 \right\} \tag{3} \]&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/efig3.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 3: $\Psi$($\phi$, $\omega$) vs. $\theta$. $\mu$ and $\phi$ are constant. $\omega$ is changed from 0 to 5.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Figure 3 shows $\Psi(\phi, \omega)$ vs. $\theta$. $\mu$ and $\phi$ are constant. $\omega$ is changed from 0 to 5. A line of $\omega=0$ is same to Fig. 1. From Fig. 3, it is found that $\Psi(\phi, \omega)$ for $\theta$ strongly depends on $\omega$. Also it is found that the change of $\Psi(\phi, \omega)$ approaches the linear increase to $\theta$ with the increase in $\omega$. Then, $\Psi(\phi, \omega)$ becomes small with the increase in $\omega$. It must pay attention that the available $\theta$ changes with the increase in $\omega$. Under $\phi = 10$, when $\omega$ is 2, $\theta$ must be more than 1000. For $\omega=5$, $\theta$ must be more than 1,000,000. The optimized $\phi$ can be obtained by the partial derivative of $\Psi(\phi, \omega)$ with respect to $\phi$ as shown in Eq.(4).&lt;/p&gt;

&lt;p&gt;\[\frac{d\Psi(\phi, \omega)}{d\phi} = \frac{\mu\theta\omega}{2}\left( 1 - \theta \phi^{-(\omega+1)} \right) \tag{4} \]&lt;/p&gt;

&lt;p&gt;When $d\Psi(\phi, \omega)/d\phi$ is 0,&lt;/p&gt;

&lt;p&gt;\[ \phi = \left( \frac{1}{\theta} \right)^{-\frac{1}{\omega+1}} \tag{5} \]&lt;/p&gt;

&lt;p&gt;For example, when $\theta$ and $\omega$ are 1,000,000, 5, respectively, $\phi=10$ is obtained using Eq. (5). The optimized $\omega$ can be obtained by deforming Eq.5 as follows.&lt;/p&gt;

&lt;p&gt;\[ \omega = \log_{\phi} \theta-1 \tag{6} \]&lt;/p&gt;

&lt;p&gt;In order to obtain optimized $\omega$ and $\phi$, either $\omega$ or $\phi$ has to be known. Therefore, at first, it is necessary to decide either $\omega$ or $\phi$. So, $\phi=10$ is used in this study.&lt;/p&gt;

&lt;p&gt;I have already talked that the processing time have to correlate to the total amount of active data $\Psi$ during the process. From theoretical results, the ratio of $\Psi$ for the standard and the pyramid method is 13,514 at $\theta = 1,000,000$. If my estimation is correct, it is considered that the ratio of processing time for the standard and the pyramid method will be large.&lt;/p&gt;

&lt;p&gt;The results of theoretical approaches indicate that the pyramid method is useful for the summation of array elements. At next section, experimental data will show the predominance of pyramid method against the standard method using GAS.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;experimental-results&#34;&gt;Experimental results&lt;/h2&gt;

&lt;p&gt;The sample array used in this study is 2 dimensional array like [[&amp;lsquo;0000000&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], [&amp;lsquo;0000001&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], [&amp;lsquo;0000002&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], ,,,]. When this array is summed, &amp;lsquo;,&amp;rsquo; and &amp;lsquo;\n&amp;rsquo; are added as a delimiter and end code, respectively. The size of an array element $\mu$ is 10 bytes. All array-elements are string.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/efig4n.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 4: Processing time vs. $\theta$ using GAS with standard method.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Figure 4 shows the processing time vs. $\theta$ obtained using the standard method by GAS. This data was obtained using a trigger command of GAS. The actual script can be seen at last section. It was found that the processing time of about 52 minutes are necessary for summing 1,000,000 array elements. Also it was found that the processing time increases proportionally to the square of $\theta$. Also this can be confirmed by the fitting function. This trend in Fig.4 is almost the same to that in Fig. 1. Namely, when the summation process is run, the change of $\Psi$ and the processing time have a correlation. In order to clarify the effect of pyramid method, the processing time vs. $\theta$ using GAS with pyramid method was measured.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/efig5n.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 5: Processing time vs. $\theta$ using GAS with pyramid method.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Figure 5 shows the processing time vs. $\theta$ using GAS with the pyramid method. For the pyramid method, under $\phi=10$, $\omega$ was optimized by the results obtained at the section of Theoretical approaches. Namely, $\omega$ and $\phi$ are changed in accordance with the number of digits of $\theta$. Each data-point was measured 10 times and adopted the average value with error bar. From Fig. 5, it was found that the processing time of the summation process becomes drastically short by adopting the pyramid method. The array elements of 1,000,000 could be summed in about 8 seconds. This is the process-cost reduction of $99.7\%$ compared with Fig. 4. Also it was found that the pyramid method changes the slope of the processing time with the increase in $\theta$ to the linear proportion. This trend corresponds to the prediction at Theoretical approaches. This is indicated that the reduction of the amount of active data during the summation process leads to reducing the process cost. From Figs. 4 and 5, it can be said that the pyramid method is very useful for the summation process with string elements in an array. Furthermore, the pyramid method is easy to apply to the filed of parallel computing. It is considered that the pyramid method can be applied to the parallel computing by giving the summation process of each group to each thread. By this, the efficiency will be much higher.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;I reported about the pyramid method for summing the string elements in an array and obtained following results.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The pyramid method could reduce the process cost of GAS for summing the string elements in an array. In the case of 2 dimensional array used in this study, the pyramid method succeed in the process-cost reduction of $99.7\%$ compared with the standard method. Is this also  Pyramid Power? ;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It was found that the pyramid method is an effectively algorithm for summing the string elements in an array.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It was found that the amount of active data during processing strongly depends on the processing time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It is considered that if the code during running is optimized in any process, the amount of active data during processing dependence on the processing time will be weak. (You can see the report which confirmed this at &lt;a href=&#34;https://tanaikech.github.io/2016/10/13/effects-on-optimized-codes-of-pyramid-method&#34;&gt;here&lt;/a&gt;.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;I would like to thank Google and Google staff.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;appendix&#34;&gt;Appendix&lt;/h2&gt;

&lt;h3 id=&#34;library-for-gas&#34;&gt;Library for GAS&lt;/h3&gt;

&lt;p&gt;A library for GAS using the pyramid method  is &lt;a href=&#34;https://github.com/tanaikech/SOUWA&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;scripts-used-at-this-report&#34;&gt;Scripts used at this report&lt;/h3&gt;

&lt;p&gt;Scripts used at this report are &lt;a href=&#34;https://github.com/tanaikech/SOUWA_test_scripts&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>