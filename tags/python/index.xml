<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on tanaike</title>
    <link>https://tanaikech.github.io/tags/python/</link>
    <description>Recent content in Python on tanaike</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Fri, 09 Jun 2017 14:27:19 +0900</lastBuildDate>
    <atom:link href="https://tanaikech.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Error Handling for Subprocess</title>
      <link>https://tanaikech.github.io/2017/06/09/error-handling-for-subprocess</link>
      <pubDate>Fri, 09 Jun 2017 14:27:19 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/09/error-handling-for-subprocess</guid>
      <description>&lt;p&gt;This sample is for error handling for subprocess.Popen. It confirms whether the execution file is existing. If the execution file is also not in the path, the error message is shown.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import subprocess

res = subprocess.Popen(
    &amp;quot;application&amp;quot;,  #  &amp;lt;- Execution file
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    shell=True
).communicate()

if len(res[1]) == 0:
    print(&amp;quot;ok: Application is existing.&amp;quot;)
else:
    print(&amp;quot;Error: Application is not found.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Using Constructor Between Classes at Python</title>
      <link>https://tanaikech.github.io/2017/06/09/using-constructor-between-classes-at-python</link>
      <pubDate>Fri, 09 Jun 2017 10:52:53 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/09/using-constructor-between-classes-at-python</guid>
      <description>

&lt;p&gt;This sample is for using constructor between classes at Python.&lt;/p&gt;

&lt;h2 id=&#34;sample&#34;&gt;Sample :&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class test1:

    def __init__(self):
        self.msg = &amp;quot;sample text&amp;quot;


class test2:

    def __init__(self):
        self.msg = test1().msg


print(test2().msg)

&amp;gt;&amp;gt;&amp;gt; sample text
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>File Transfer for Google Drive Without Authorization</title>
      <link>https://tanaikech.github.io/2017/05/10/file-transfer-for-google-drive-without-authorization</link>
      <pubDate>Wed, 10 May 2017 13:28:28 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/05/10/file-transfer-for-google-drive-without-authorization</guid>
      <description>

&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;

&lt;p&gt;In this article, I would like to introduce how to transfer files for Google Drive under no authorization.&lt;/p&gt;

&lt;p&gt;This has also been published here. &lt;a href=&#34;https://github.com/tanaikech/FileTransfer&#34;&gt;https://github.com/tanaikech/FileTransfer&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;description&#34;&gt;Description&lt;/h1&gt;

&lt;p&gt;When we download and upload files for Google Drive, it usually has to use Drive API. In order to use Drive API, access token is required. If you want to make your friends download and upload files for your Google Drive, the authorization process is to take time. So I proposal this.&lt;/p&gt;

&lt;p&gt;As a sample, I introduce a script for downloading and uploading files using Web Apps. In this sample, it changes a file to a byte slice and send it as text data. Then, it reconstructs it. Of course, base64 encode can be used for this. But the data size for using base64 is much larger than that for using the byte slice.&lt;/p&gt;

&lt;p&gt;At this method, the project files including GAS script cannot be downloaded. When a script file is uploaded, it is converted to text file which is not a project file of Google. When Google Docs can be downloaded using this method, those are downloaded as PDF file. docx, pptx and xlsx can be uploaded.&lt;/p&gt;

&lt;p&gt;They say taht the limitation size of an uploading file is 24 MBytes. &lt;a href=&#34;http://stackoverflow.com/questions/38315816/max-size-for-post-request-sent-to-webapps&#34;&gt;Ref.&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;usage&#34;&gt;Usage&lt;/h1&gt;

&lt;h2 id=&#34;1-u-deploy-web-apps-https-developers-google-com-apps-script-guides-web-u&#34;&gt;1. &lt;u&gt;&lt;a href=&#34;https://developers.google.com/apps-script/guides/web&#34;&gt;Deploy Web Apps&lt;/a&gt;&lt;/u&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Open the Script Editor.&lt;/li&gt;
&lt;li&gt;On the Script Editor

&lt;ul&gt;
&lt;li&gt;File -&amp;gt; Manage Versions -&amp;gt; Save New Version&lt;/li&gt;
&lt;li&gt;Publish -&amp;gt; Deploy as Web App&lt;/li&gt;
&lt;li&gt;At Execute the app as, select &lt;strong&gt;&amp;ldquo;your account&amp;rdquo;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;At Who has access to the app, select &lt;strong&gt;&amp;ldquo;Anyone, even anonymous&amp;rdquo;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Click &amp;ldquo;Deploy&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Copy &lt;strong&gt;&amp;ldquo;Current web app URL&amp;rdquo;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Click &amp;ldquo;OK&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;2-paste-following-script-on-script-editor&#34;&gt;2. Paste following script on Script Editor.&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function doPost(e) {
  if (e.parameters.method == &amp;quot;download&amp;quot;) {
    try {
      return (function(id){
        var file = DriveApp.getFileById(id);
        return ContentService
              .createTextOutput(JSON.stringify({
                size: file.getBlob().getBytes(),
                name: file.getName(),
                result: file.getName() + &amp;quot; (&amp;quot; + file.getBlob().getContentType() + &amp;quot;)&amp;quot;
              }))
              .setMimeType(ContentService.MimeType.JSON);
      })(e.parameters.id);
    } catch(err) {
      return ContentService.createTextOutput(JSON.stringify({
                result: err.message
              }))
              .setMimeType(ContentService.MimeType.JSON);
    }
  }

  if (e.parameters.method == &amp;quot;upload&amp;quot;) {
    try {
      return ContentService
              .createTextOutput(JSON.stringify({
                result: (function(p){
                  return DriveApp
                    .createFile(
                      Utilities.newBlob(
                        [parseInt(i, 10) for each (i in p.file)],
                        p.mime,
                        p.name
                      )
                    )
                    .getId();
                })(e.parameters)
              }))
              .setMimeType(ContentService.MimeType.JSON);
    } catch(err) {
      return ContentService.createTextOutput(JSON.stringify({
                result: err.message
              }))
              .setMimeType(ContentService.MimeType.JSON);
    }
  }

  if (e.parameters.method == &amp;quot;delete&amp;quot;) {
    try {
      DriveApp.getFileById(e.parameters.id).setTrashed(true);
      return ContentService.createTextOutput(JSON.stringify({
                result: e.parameters.id + &amp;quot; was deleted.&amp;quot;
              }))
              .setMimeType(ContentService.MimeType.JSON);
    } catch(err) {
      return ContentService.createTextOutput(JSON.stringify({
                result: err.message
              }))
              .setMimeType(ContentService.MimeType.JSON);
    }
  }

  return ContentService.createTextOutput(&amp;quot;Did nothing.&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-at-local-pc-use-following-script&#34;&gt;3. At local pc, use following script.&lt;/h2&gt;

&lt;p&gt;There are 3 methods of &lt;code&gt;download()&lt;/code&gt;, &lt;code&gt;upload()&lt;/code&gt; and &lt;code&gt;delete()&lt;/code&gt;. When you use those, please give a value of file ID to&lt;code&gt;download()&lt;/code&gt; and &lt;code&gt;delete()&lt;/code&gt;. Then please give file name to &lt;code&gt;upload()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import mimetypes
import numpy as np
import requests

# Please paste &amp;quot;Current web app URL&amp;quot; here.
url = &amp;quot;https://script.google.com/macros/s/#####/exec&amp;quot;


def download(fileid):
    r = requests.post(
        url,
        data={&amp;quot;method&amp;quot;: &amp;quot;download&amp;quot;, &amp;quot;id&amp;quot;: fileid}
    )
    if len(r.json()[&amp;quot;name&amp;quot;]) &amp;gt; 0:
        with open(r.json()[&amp;quot;name&amp;quot;], &amp;quot;bw&amp;quot;) as f:
            f.write(np.array(r.json()[&amp;quot;size&amp;quot;], dtype=np.uint8))
    return r.json()[&amp;quot;result&amp;quot;]


def upload(filename):
    with open(filename, &amp;quot;rb&amp;quot;) as f:
        d = f.read()
    r = requests.post(
        url,
        data={
            &amp;quot;method&amp;quot;: &amp;quot;upload&amp;quot;,
            &amp;quot;file&amp;quot;: [(-(i &amp;amp; 0b10000000) | (i &amp;amp; 0b01111111)) for i in d],
            &amp;quot;name&amp;quot;: filename,
            &amp;quot;mime&amp;quot;: mimetypes.guess_type(filename)[0]
        }
    )
    return r.json()[&amp;quot;result&amp;quot;]


def delete(fileid):
    r = requests.post(
        url,
        data={&amp;quot;method&amp;quot;: &amp;quot;delete&amp;quot;, &amp;quot;id&amp;quot;: fileid}
    )
    return r.json()[&amp;quot;result&amp;quot;]

def main():
    fileid = &amp;quot;#####&amp;quot;
    print(download(fileid))

    filename = &amp;quot;#####&amp;quot;
    print(upload(filename))

    fileid = &amp;quot;#####&amp;quot;
    print(delete(fileid))

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Download files have no extension. So please add the extension for each mimeType to the files.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OCR using Google Drive API</title>
      <link>https://tanaikech.github.io/2017/05/02/ocr-using-google-drive-api</link>
      <pubDate>Tue, 02 May 2017 14:21:55 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/05/02/ocr-using-google-drive-api</guid>
      <description>&lt;p&gt;This is a sample script for OCR using Google Drive API. A text file which converted by OCR can be retrieved by inputting an image file.&lt;/p&gt;

&lt;p&gt;In this sample, Python Quickstart is used. The detail information is &lt;a href=&#34;https://developers.google.com/drive/v3/web/quickstart/python&#34;&gt;https://developers.google.com/drive/v3/web/quickstart/python&lt;/a&gt;. Please read “Step 1: Turn on the Drive API” and “Step 2: Install the Google Client Library”.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import print_function
import httplib2
import os
import io

from apiclient import discovery
from oauth2client import client
from oauth2client import tools
from oauth2client.file import Storage
from apiclient.http import MediaFileUpload, MediaIoBaseDownload

try:
    import argparse
    flags = argparse.ArgumentParser(parents=[tools.argparser]).parse_args()
except ImportError:
    flags = None

# If modifying these scopes, delete your previously saved credentials
# at ~/.credentials/drive-python-quickstart.json
SCOPES = &#39;https://www.googleapis.com/auth/drive&#39;
CLIENT_SECRET_FILE = &#39;client_secret.json&#39;
APPLICATION_NAME = &#39;Drive API Python Quickstart&#39;


def get_credentials():
    &amp;quot;&amp;quot;&amp;quot;Gets valid user credentials from storage.

    If nothing has been stored, or if the stored credentials are invalid,
    the OAuth2 flow is completed to obtain the new credentials.

    Returns:
        Credentials, the obtained credential.
    &amp;quot;&amp;quot;&amp;quot;
    credential_path = os.path.join(&amp;quot;./&amp;quot;, &#39;drive-python-quickstart.json&#39;)
    store = Storage(credential_path)
    credentials = store.get()
    if not credentials or credentials.invalid:
        flow = client.flow_from_clientsecrets(CLIENT_SECRET_FILE, SCOPES)
        flow.user_agent = APPLICATION_NAME
        if flags:
            credentials = tools.run_flow(flow, store, flags)
        else:  # Needed only for compatibility with Python 2.6
            credentials = tools.run(flow, store)
        print(&#39;Storing credentials to &#39; + credential_path)
    return credentials


def main():
    credentials = get_credentials()
    http = credentials.authorize(httplib2.Http())
    service = discovery.build(&#39;drive&#39;, &#39;v3&#39;, http=http)

    imgfile = &#39;sample.png&#39;  # Image with texts (png, jpg, bmp, gif, pdf)
    txtfile = &#39;output.txt&#39;  # Text file outputted by OCR

    mime = &#39;application/vnd.google-apps.document&#39;
    res = service.files().create(
        body={
            &#39;name&#39;: imgfile,
            &#39;mimeType&#39;: mime
        },
        media_body=MediaFileUpload(imgfile, mimetype=mime, resumable=True)
    ).execute()

    downloader = MediaIoBaseDownload(
        io.FileIO(txtfile, &#39;wb&#39;),
        service.files().export_media(fileId=res[&#39;id&#39;], mimeType=&amp;quot;text/plain&amp;quot;)
    )
    done = False
    while done is False:
        status, done = downloader.next_chunk()

    service.files().delete(fileId=res[&#39;id&#39;]).execute()
    print(&amp;quot;Done.&amp;quot;)


if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Converting PDF to TXT</title>
      <link>https://tanaikech.github.io/2017/05/01/converting-pdf-to-txt</link>
      <pubDate>Mon, 01 May 2017 15:04:30 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/05/01/converting-pdf-to-txt</guid>
      <description>&lt;p&gt;This is a sample script for converting a PDF file to a TXT file. 2 steps are required for this.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Upload a PDF file as a Google Document&lt;/li&gt;
&lt;li&gt;Download a Google Document as a TXT file&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this sample, Python Quickstart is used. The detail information is &lt;a href=&#34;https://developers.google.com/drive/v3/web/quickstart/python&#34;&gt;https://developers.google.com/drive/v3/web/quickstart/python&lt;/a&gt;. Please read &amp;ldquo;Step 1: Turn on the Drive API&amp;rdquo; and &amp;ldquo;Step 2: Install the Google Client Library&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import print_function
import httplib2
import os
import io

from apiclient import discovery
from oauth2client import client
from oauth2client import tools
from oauth2client.file import Storage
from apiclient.http import MediaFileUpload, MediaIoBaseDownload

try:
    import argparse
    flags = argparse.ArgumentParser(parents=[tools.argparser]).parse_args()
except ImportError:
    flags = None

SCOPES = &#39;https://www.googleapis.com/auth/drive&#39;
CLIENT_SECRET_FILE = &#39;client_secret.json&#39;
APPLICATION_NAME = &#39;Drive API Python Quickstart&#39;


def get_credentials():
    credential_path = os.path.join(&amp;quot;./&amp;quot;, &#39;drive-python-quickstart.json&#39;)
    store = Storage(credential_path)
    credentials = store.get()
    if not credentials or credentials.invalid:
        flow = client.flow_from_clientsecrets(CLIENT_SECRET_FILE, SCOPES)
        flow.user_agent = APPLICATION_NAME
        if flags:
            credentials = tools.run_flow(flow, store, flags)
        else:  # Needed only for compatibility with Python 2.6
            credentials = tools.run(flow, store)
        print(&#39;Storing credentials to &#39; + credential_path)
    return credentials


def main():
    credentials = get_credentials()
    http = credentials.authorize(httplib2.Http())
    service = discovery.build(&#39;drive&#39;, &#39;v3&#39;, http=http)

    pdffile = &#39;sample.pdf&#39;
    txtfile = &#39;sample.txt&#39;

    mime = &#39;application/vnd.google-apps.document&#39;
    res = service.files().create(
        body={
            &#39;name&#39;: pdffile,
            &#39;mimeType&#39;: mime
        },
        media_body=MediaFileUpload(pdffile, mimetype=mime, resumable=True)
    ).execute()

    dl = MediaIoBaseDownload(
        io.FileIO(txtfile, &#39;wb&#39;),
        service.files().export_media(fileId=res[&#39;id&#39;], mimeType=&amp;quot;text/plain&amp;quot;)
    )
    done = False
    while done is False:
        status, done = dl.next_chunk()
    print(&amp;quot;Done.&amp;quot;)


if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Download Files Without Authorization From Google Drive</title>
      <link>https://tanaikech.github.io/2017/03/20/download-files-without-authorization-from-google-drive</link>
      <pubDate>Mon, 20 Mar 2017 14:30:15 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/03/20/download-files-without-authorization-from-google-drive</guid>
      <description>

&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;

&lt;p&gt;In this article, files can be downloaded without authorization.&lt;/p&gt;

&lt;h1 id=&#34;description&#34;&gt;Description&lt;/h1&gt;

&lt;p&gt;When we download files from Google Drive, it usually has to use Drive API. In order to use Drive API, access token is required. If you want to make your friends download files from your Google Drive, the authorization process is to take time. Also Web Link for each files can be used. But it has to set for each files. So I proposal this.&lt;/p&gt;

&lt;p&gt;As a sample, I introduce a script for downloading the files using Web Apps. In this sample, it changes a file to a byte slice and send it as text data. Then, it reconstructs it. Of course, base64 encode can be used for this. But the data size for using base64 is much larger than that for using the byte slice.&lt;/p&gt;

&lt;p&gt;At this method, the project files including GAS script cannot be downloaded. When Google Docs are downloaded using this method, those are downloaded as PDF file. It may be the specification of Google.&lt;/p&gt;

&lt;p&gt;By the way, also you can upload files without authorization to Google Drive using this method.&lt;/p&gt;

&lt;h1 id=&#34;usage&#34;&gt;Usage&lt;/h1&gt;

&lt;h2 id=&#34;1-u-deploy-web-apps-https-developers-google-com-apps-script-guides-web-u&#34;&gt;1. &lt;u&gt;&lt;a href=&#34;https://developers.google.com/apps-script/guides/web&#34;&gt;Deploy Web Apps&lt;/a&gt;&lt;/u&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Open the Script Editor.&lt;/li&gt;
&lt;li&gt;On the Script Editor

&lt;ul&gt;
&lt;li&gt;File -&amp;gt; Manage Versions -&amp;gt; Save New Version&lt;/li&gt;
&lt;li&gt;Publish -&amp;gt; Deploy as Web App&lt;/li&gt;
&lt;li&gt;At Execute the app as, select &lt;strong&gt;&amp;ldquo;your account&amp;rdquo;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;At Who has access to the app, select &lt;strong&gt;&amp;ldquo;Anyone, even anonymous&amp;rdquo;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Click &amp;ldquo;Deploy&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Copy &lt;strong&gt;&amp;ldquo;Current web app URL&amp;rdquo;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Click &amp;ldquo;OK&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;2-paste-following-script-on-script-editor&#34;&gt;2. Paste following script on Script Editor.&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function doPost(e) {
  return (function(id){
    var file = DriveApp.getFileById(id);
    return ContentService
          .createTextOutput(JSON.stringify({
            result: file.getBlob().getBytes(),
            name: file.getName(),
            mimeType: file.getBlob().getContentType()
          }))
          .setMimeType(ContentService.MimeType.JSON);
  })(e.parameters.id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-at-local-pc-use-following-script&#34;&gt;3. At local pc, use following script.&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
import requests
r = requests.post(
    &amp;quot;https://script.google.com/macros/s/### Your ID ###/exec&amp;quot;,
    data={&amp;quot;id&amp;quot;: &amp;quot;### File ID ###&amp;quot;}
)
f = open(r.json()[&amp;quot;name&amp;quot;], &amp;quot;bw&amp;quot;)
f.write(np.array(r.json()[&amp;quot;result&amp;quot;], dtype=np.uint8))
f.close()
print(&amp;quot;Filename = {0}, MimeType = {1}&amp;quot;.format(r.json()[&amp;quot;name&amp;quot;], r.json()[&amp;quot;mimeType&amp;quot;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Files output from this sample have no extension. So please add the extension for each mimeType to the files.&lt;/p&gt;

&lt;h1 id=&#34;appendix&#34;&gt;Appendix&lt;/h1&gt;

&lt;p&gt;If you want to download with authorization, there are &lt;a href=&#34;https://developers.google.com/drive/v3/web/manage-downloads&#34;&gt;3 patterns&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/apps-script/import-export&#34;&gt;Download script and project including script.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/drive/v3/reference/files/export&#34;&gt;Download Google Docs (spreadsheet, document, presentation and so on). In this case, Google calls &amp;ldquo;Export&amp;rdquo;.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/drive/v3/reference/files/get&#34;&gt;Download files except for Google Docs.&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Python Library - souwapy</title>
      <link>https://tanaikech.github.io/2016/10/30/python-library---souwapy</link>
      <pubDate>Sun, 30 Oct 2016 13:38:29 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2016/10/30/python-library---souwapy</guid>
      <description>&lt;p&gt;This &amp;ldquo;souwapy&amp;rdquo; is a library for summing array elements with high speed by new algorithm (&lt;a href=&#34;https://tanaikech.github.io/2016/10/13/improved-algorithms-for-summation-of-array-elements/&#34;&gt;Pyramid method&lt;/a&gt;). The speed is faster than csv and panbdas module of python and v8 engine of node.js. The souwapy module is 2.3 and 3.1 times faster than csv and pandas module, respectively. This was really surprised me. It was found that the theory was correct.&lt;/p&gt;

&lt;p&gt;At first, I have created this theory for Google Apps Script. But recently I had to use large data and output a csv file on python. So I made this library. Additionally, I had wanted to know how to public own library to PyPI before. This chance was good for me. If this library is helpful for other people, I&amp;rsquo;m glad.&lt;/p&gt;

&lt;p&gt;The detailed information of souwapy is as follows. You can know how to install and use this library.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;PyPI &amp;ndash;&amp;gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://pypi.python.org/pypi/souwapy&#34;&gt;https://pypi.python.org/pypi/souwapy&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;GitHub &amp;ndash;&amp;gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/tanaikech/souwapy&#34;&gt;https://github.com/tanaikech/souwapy&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Element&#39;s Duplicate Number in Array at Python</title>
      <link>https://tanaikech.github.io/2016/10/21/elements-duplicate-number-in-array-at-python</link>
      <pubDate>Fri, 21 Oct 2016 12:29:25 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2016/10/21/elements-duplicate-number-in-array-at-python</guid>
      <description>&lt;p&gt;Suddenly I had to need this.&lt;/p&gt;

&lt;p&gt;This script can get the duplicate number of each element in array at Python. In this script, the duplicate number of each element is obtained and sorted by the duplicate number. This was expressed by the comprehension.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;b&#39;]
result = sorted({i: data.count(i) for i in set(data)}.items(), key=lambda x: x[1], reverse=True)
print(result)

&amp;gt;&amp;gt;&amp;gt; [(&#39;b&#39;, 4), (&#39;c&#39;, 3), (&#39;d&#39;, 2), (&#39;a&#39;, 1)]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>GAS Library - SOUWA_GAS - Effects on Optimized Codes of Pyramid Method</title>
      <link>https://tanaikech.github.io/2016/10/13/gas-library---souwa_gas---effects-on-optimized-codes-of-pyramid-method</link>
      <pubDate>Thu, 13 Oct 2016 15:57:20 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2016/10/13/gas-library---souwa_gas---effects-on-optimized-codes-of-pyramid-method</guid>
      <description>

&lt;p&gt;&lt;center&gt;
Kanshi TANAIKE
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;#ref1&#34;&gt;I have already reported that the pyramid method is one of very effectively algolithms for summing string elements in an array using Google Apps Script (GAS).&lt;/a&gt; This report describes the adaptability of the pyramid method to any languages except for GAS. c++ (g++), Go, Java, Javascript on Node.js, Python and Ruby were chosen as the sample languages. In those languages, there are languages which have the distinctive commands for summing the array elements. In this report, &amp;ldquo;+&amp;rdquo; operator as a standard command and a special command for each language were used. For c++ (g++), Javascript on Node.js and Python which have no distinctive commands for summing the array elements, only &amp;ldquo;+&amp;rdquo; operator was used. For others, both &amp;ldquo;+&amp;rdquo; operator and each special command such as &amp;ldquo;[]byte&amp;rdquo;, &amp;ldquo;StringBuilder&amp;rdquo; and &amp;ldquo;&amp;lt;&amp;lt;&amp;rdquo; were used. For languages without the distinctive commands for summing, the pyramid method made us show some interesting phenomena. It was found that the pyramid method shows a good effect on only the specific language. It was found that &amp;ldquo;+&amp;rdquo; operator had been optimized for g++ and Node.js. &amp;ldquo;+&amp;rdquo; operator of Python was corresponding to theoretical results. This means that &amp;ldquo;+&amp;rdquo; operator of Python is not optimized. On the other hand, for languages with the distinctive commands for summing, it was found that the distinctive commands is incompatible to the pyramid method. These results made us show the possibility of visualization for the optimized codes.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;When the string elements in an array are summed by a script, there are various patterns for each language. A standard algorithm is the method using &amp;ldquo;+&amp;rdquo; operator as following a pseudo code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Declare a string variable arr, sum
    Declare an integer variable loopcounter
    Set arr to size n
    for loopcounter = 0 to (size of arr) - 1
        sum = sum + arr[loopcounter]
        loopcounter = loopcounter + 1
    endfor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some languages have the special commands (&amp;rdquo;[]byte&amp;rdquo;, &amp;ldquo;StringBuilder&amp;rdquo; and &amp;ldquo;&amp;lt;&amp;lt;&amp;ldquo;) for summing string elements except for &amp;ldquo;+&amp;rdquo; operator. Such languages can sum elements effectively using the special commands even if the standard method was used. However the languages which have no special commands must use only &amp;ldquo;+&amp;rdquo; operator. I had experienced that at GAS. Therefore, I have proposed the pyramid method. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;] It had been found that the pyramid method is high efficiency for summing the array elements at GAS. It is very important for today, which have increased the opportunity to handle the strings, to efficiently sum the strings. In this report, I have investigated about the adaptability of pyramid method to any languages.&lt;/p&gt;

&lt;p&gt;Now I have 2 patterns of the standard method and the pyramid method for summing array elements. Furthermore, those 2 patterns were demonstrated by experimental and theoretical approaches. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;] I have thought that the optimization of each language may be able to be evaluated using as those tools. In this study, those tools made us show some interesting phenomena. The pyramid method showed a good effect on only the specific language using &amp;ldquo;+&amp;rdquo; operator. It was found that the languages which showed no good effect had had the optimized &amp;ldquo;+&amp;rdquo; operator. It is considered that this is due to the optimization engine of interpreters and compilers. It was found that the languages with the special commands for summing array elements are incompatible to the pyramid method. These results say that the languages with &amp;ldquo;+&amp;rdquo; operator without the optimization can benefit from the pyramid method. Also it is considered that the pyramid method can be used to evaluate the optimization engine. The result in this study gave us the possibility of visualization for optimized codes. So there are two aims of this report. One is to confirm the effects on various languages of the pyramid methods. And another is to consider the visualization of optimization engine.&lt;/p&gt;

&lt;p&gt;For the detailed information of the standard method and the pyramid method which are used in this report, you can see them. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;experimental-procedure&#34;&gt;Experimental procedure&lt;/h2&gt;

&lt;p&gt;$\Psi, \mu, \theta, \phi$ and $\omega$ which are used in this report are the total amount of active data during the summing process, the size of one array-element, the number of total array elements, the size of division for dividing array and the number of divisions for the pyramid method, respectively. The detailed information of them are &lt;a href=&#34;#ref1&#34;&gt;here&lt;/a&gt;. The array used in this study is 2 dimensional array constructed with strings such as [[&amp;lsquo;0000000&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], [&amp;lsquo;0000001&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], [&amp;lsquo;0000002&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], ,,,]. When this array is summed, &amp;lsquo;,&amp;rsquo; and &amp;lsquo;\n&amp;rsquo; are added as a delimiter and an end code, respectively. So the size of an element $\mu$ becomes 10 bytes. The optimized $\omega$ and $\phi$ were obtained by report [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;]. Those are $\omega=\log_{10} \theta - 1, \phi=(1/\theta)^{-1/(\omega+1)}$. The languages which were chosen for this study are shown in table 1. c++ sources were compiled by g++ (6.1.0 on msys2) with the option &amp;ldquo;-O2&amp;rdquo;. The PC spec which was used for measuring data in this study is CPU Core i5-3210M, Memory 8 GB, OS Windows10 (x64) (v1607).&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Table 1: Languages used in this study.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Language&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c++&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;Compiler g++ (6.1.0 on msys2)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Go&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v1.7.1 windows/amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v8 (1.8.0_101)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Javascript on Node.js&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v6.3.0 (v8 &amp;lsquo;5.0.71.52&amp;rsquo;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Python&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v3.5.2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Ruby&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v2.3.1p112&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;results-and-discussions&#34;&gt;Results and discussions&lt;/h2&gt;

&lt;p&gt;Figures 1 - 6 show the behavior of the processing time for each language with the increase in $\theta$ which is the number of array elements. All figures were put in a table. Left side shows the results taken from the measurements using &amp;ldquo;+&amp;rdquo; operator. Right side shows the results taken from the measurements using the distinctive commands of each language.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/gpp1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 1: g++ using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/node1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 2: Javascript on Node.js using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/py1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 3: Python using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/go1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/go2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 4(a): Go using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 4(b): Go using &amp;ldquo;[]byte&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/go2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 4(c): Go using &amp;ldquo;[]byte&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/java1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/java2.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 5(a): Java using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 5(b): Java using &amp;ldquo;StringBuilder&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/ruby1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/ruby2.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 6(a): Ruby using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 6(b): Ruby using &amp;ldquo;&amp;lt;&amp;lt;&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;g++, Node.js and Python in Figs. 1 - 3 have no distinctive commands except for &amp;ldquo;+&amp;rdquo; operator. Go, Java and Ruby in Figs. 4 - 6 have distinctive commands. For the results of &amp;ldquo;+&amp;rdquo; operator, the language except for g++ and Node.js can be confirmed the effect of the pyramid method. Especially, Python and Ruby in Figs. 3 and 6(a) show the behavior corresponding to theoretical results which had been already reported by me. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;] For the standard method, $\Psi$, which is the total amount of active data during summing, increases proportionally to the square of $\theta$. For the pyramid method, $\Psi$ linearly increases with the increase in $\theta$. Go and Java in Figs. 4(a) and 5(a) show the increase of $\Psi$ proportionally to the square of $\theta$ for both red and blue lines. The optimization may influence to the process of pyramid method. g++ and Node.js in Figs. 1 and 2 show no effect of the pyramid method. It is considered that &amp;ldquo;+&amp;rdquo; operator is optimized for g++ and Node.js which have no special commands for summing array elements. V8 engine of Node.js is known as one of the optimization engines. The optimization may influence to only the standard method or disturb the work of pyramid method. For Go, Java and Ruby which have the special commands for summing, the pyramid method shows no effect as shown in Figs. 4(b), 4(c), 5(b) and 6(b). Also it is considered that this is due to the optimization. In Figs. 1, 2, 4(b), 5(b) and 6(b), $\Psi$ linearly increases with the increase in $\theta$ for the standard method. Furthermore, the reverse phenomenon that the process speed of standard method becomes faster than that of pyramid method occurs in those figures. These clearly show the optimization of summing process. In order to consider these, it thinks of the number of loops during summing process. The number of loops $N_{l}$ during summing process can be expressed as follows.&lt;/p&gt;

&lt;p&gt;\[ N_{l} = \sum_{k=1}^{\omega - 1} \frac{\theta}{\phi^{k}} \tag{1} \]&lt;/p&gt;

&lt;p&gt;From Eq. (1), $N_{l0} = \theta$ at $\omega=0$ and $N_{li} = \theta(1 - \phi^{-1})^{-1}$ at $\omega=\infty$ can be obtained. Therefore, the increasing rate $\varepsilon$ from $N_{l0}$ to $N_{li}$ becomes as follows.&lt;/p&gt;

&lt;p&gt;\[ \varepsilon = 100 \times \frac{1}{(\phi - 1)} \tag{2} \]&lt;/p&gt;

&lt;p&gt;where the unit is $\%$. $\omega = 0$ and $\omega \geqq 1$ mean the standard and the pyramid method, respectively. Here, since this study was performed under the condition of $\theta = 1,000,000$ and $\phi = 10$, $\varepsilon$ is $11\%$ and the number of loops of the pyramid method increases 11,000 for that of the standard method under this condition. In this study, the number of loops for the pyramid method is $11\%$ larger than that of the standard method. Then, I think that when the languages for summing process are optimized, the search of last address of each string is much faster than that of languages without the optimization. By these, when the languages have the special commands for summing array elements and the optimized &amp;ldquo;+&amp;rdquo; operator, it is considered that the processing time strongly depends on the number of loops in the code rather than $\Psi$. Therefore, it is considered that the reverse phenomenon occurs for the processing time between the standard and the pyramid method as shown in Figs. 1, 2, 5(b) and 6(b). And the reverse phenomenon is remarkable, since the speed of g++ is much faster than that of other languages.&lt;/p&gt;

&lt;p&gt;Here, when Figs. 2 and 6(b) are compared, it is found that both behaviors of $\Psi$ for the increase in $\theta$ are almost the same. At $\theta = 1,000,000$ of the standard method, the processing time is 1.13 s and 1.25 s for Node.js and Ruby, respectively. It may indicate that both optimization is almost the same.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/rank.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 7: Top 10 data of processing time for each language at $\theta = 1,000,000$.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Figure 7 shows the summing process-time for each language at $\theta = 1,000,000$. The top 10 data are shown in Fig. 7. This figure shows the high performance of languages (g++, Go and Java) compiled by the compiler. There is two interesting points. 1st point is the result of Python using the pyramid method. Python using the pyramid method shows 2 times faster in the processing speed than Node.js with V8 engine. When it thinks that the processing time of Python using the standard method at $\theta = 1,000,000$ is 6.1 s, this is the remarkable data for the pyramid method. And for $\theta = 5,000,000$, the processing speed of Python is 2.6 times faster than that of Node.js. In the 2nd point, for Go and Ruby, it was found that &amp;ldquo;[]byte&amp;rdquo; and &amp;ldquo;&amp;lt;&amp;lt;&amp;rdquo; are predominantly optimized compared to &amp;ldquo;+&amp;rdquo; operator.&lt;/p&gt;

&lt;p&gt;From the results in this study, it was found that the pyramid method is efficient for languages except for GAS. Especially, languages corresponding to the trend of theoretical results are more efficiently. Languages, which have distinctive optimized commands for summing array elements, should use both the special commands and the standard method. Languages which needs to compile should use the standard method. These results can also be used to the visualization of optimization engine.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Following results could be obtained in this study.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The pyramid method for summing array elements is efficient for the languages except for GAS.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Languages with &amp;ldquo;+&amp;rdquo; operator without the optimization can benefit from the pyramid method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Languages, which have distinctive optimized commands for summing array elements, should use both the special commands and the standard method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The pyramid method can be used to evaluate the optimization engine.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The result in this study gave us the possibility of visualization for optimized codes.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://tanaikech.github.io/2016/10/13/improved-algorithms-for-summation-of-array-elements&#34;&gt;&amp;ldquo;Improved Algorithms for Summation of Array Elements&amp;rdquo;, October 13, 2016&lt;/a&gt;
&lt;a name=&#34;ref1&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;appendix&#34;&gt;Appendix&lt;/h2&gt;

&lt;p&gt;Scripts used at this report are &lt;a href=&#34;https://github.com/tanaikech/SOUWA_test_scripts&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>