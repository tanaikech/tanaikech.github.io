<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Google on tanaike</title>
    <link>https://tanaikech.github.io/tags/google/</link>
    <description>Recent content in Google on tanaike</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Mon, 01 May 2017 15:04:30 +0900</lastBuildDate>
    <atom:link href="https://tanaikech.github.io/tags/google/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Converting PDF to TXT</title>
      <link>https://tanaikech.github.io/2017/05/01/converting-pdf-to-txt</link>
      <pubDate>Mon, 01 May 2017 15:04:30 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/05/01/converting-pdf-to-txt</guid>
      <description>&lt;p&gt;This is a sample script for converting a PDF file to a TXT file. 2 steps are required for this.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Upload a PDF file as a Google Document&lt;/li&gt;
&lt;li&gt;Download a Google Document as a TXT file&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this sample, Python Quickstart is used. The detail information is &lt;a href=&#34;https://developers.google.com/drive/v3/web/quickstart/python&#34;&gt;https://developers.google.com/drive/v3/web/quickstart/python&lt;/a&gt;. Please read &amp;ldquo;Step 1: Turn on the Drive API&amp;rdquo; and &amp;ldquo;Step 2: Install the Google Client Library&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import print_function
import httplib2
import os
import io

from apiclient import discovery
from oauth2client import client
from oauth2client import tools
from oauth2client.file import Storage
from apiclient.http import MediaFileUpload, MediaIoBaseDownload

try:
    import argparse
    flags = argparse.ArgumentParser(parents=[tools.argparser]).parse_args()
except ImportError:
    flags = None

SCOPES = &#39;https://www.googleapis.com/auth/drive&#39;
CLIENT_SECRET_FILE = &#39;client_secret.json&#39;
APPLICATION_NAME = &#39;Drive API Python Quickstart&#39;


def get_credentials():
    credential_path = os.path.join(&amp;quot;./&amp;quot;, &#39;drive-python-quickstart.json&#39;)
    store = Storage(credential_path)
    credentials = store.get()
    if not credentials or credentials.invalid:
        flow = client.flow_from_clientsecrets(CLIENT_SECRET_FILE, SCOPES)
        flow.user_agent = APPLICATION_NAME
        if flags:
            credentials = tools.run_flow(flow, store, flags)
        else:  # Needed only for compatibility with Python 2.6
            credentials = tools.run(flow, store)
        print(&#39;Storing credentials to &#39; + credential_path)
    return credentials


def main():
    credentials = get_credentials()
    http = credentials.authorize(httplib2.Http())
    service = discovery.build(&#39;drive&#39;, &#39;v3&#39;, http=http)

    pdffile = &#39;sample.pdf&#39;
    txtfile = &#39;sample.txt&#39;

    mime = &#39;application/vnd.google-apps.document&#39;
    res = service.files().create(
        body={
            &#39;name&#39;: pdffile,
            &#39;mimeType&#39;: mime
        },
        media_body=MediaFileUpload(pdffile, mimetype=mime, resumable=True)
    ).execute()

    dl = MediaIoBaseDownload(
        io.FileIO(txtfile, &#39;wb&#39;),
        service.files().export_media(fileId=res[&#39;id&#39;], mimeType=&amp;quot;text/plain&amp;quot;)
    )
    done = False
    while done is False:
        status, done = dl.next_chunk()
    print(&amp;quot;Done.&amp;quot;)


if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CLI Tool - goris</title>
      <link>https://tanaikech.github.io/2017/04/26/cli-tool---goris</link>
      <pubDate>Wed, 26 Apr 2017 16:52:10 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/04/26/cli-tool---goris</guid>
      <description>

&lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;

&lt;p&gt;This is a CLI tool to search for images with &lt;strong&gt;Go&lt;/strong&gt;ogle &lt;strong&gt;R&lt;/strong&gt;everse &lt;strong&gt;I&lt;/strong&gt;mage &lt;strong&gt;S&lt;/strong&gt;earch.&lt;/p&gt;

&lt;h3 id=&#34;motivation&#34;&gt;Motivation&lt;/h3&gt;

&lt;p&gt;Because I had wanted to search for images with an image URL and file on my terminal, I created this. This can download images from searched image URLs.&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;#3366CC&#34;&gt;&lt;strong&gt;The detail information and how to get this are &lt;a href=&#34;https://github.com/tanaikech/goris&#34;&gt;https://github.com/tanaikech/goris&lt;/a&gt;.&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Updated: CLI Tool - gogauth</title>
      <link>https://tanaikech.github.io/2017/04/19/updated-cli-tool---gogauth</link>
      <pubDate>Wed, 19 Apr 2017 13:34:36 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/04/19/updated-cli-tool---gogauth</guid>
      <description>&lt;p&gt;gogauth is a CLI tool to retrieve easily access token for using APIs on Google.&lt;/p&gt;

&lt;p&gt;Today, it was updated with big changes. Please check it out.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tanaikech/gogauth&#34;&gt;https://github.com/tanaikech/gogauth&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CLI Tool - gogauth</title>
      <link>https://tanaikech.github.io/2017/02/24/cli-tool---gogauth</link>
      <pubDate>Fri, 24 Feb 2017 12:29:32 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/02/24/cli-tool---gogauth</guid>
      <description>&lt;p&gt;Released a CLI tool for easily retrieving accesstoken from Google OAuth2. The title is &lt;strong&gt;&lt;a href=&#34;https://github.com/tanaikech/gogauth&#34;&gt;gogauth&lt;/a&gt;&lt;/strong&gt;. When I have seen stackoverflow, I knew that it is difficult to retrieve accesstoken from Google OAuth2. So I made this.&lt;/p&gt;

&lt;p&gt;Features of this CLI tool are as follows.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Retrieves easily accesstoken from Google OAuth2 for using Drive API.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you have PhantomeJS, this retrieves &amp;ldquo;code&amp;rdquo; from Google using it. So you don&amp;rsquo;t need to launch your browser for retrieving &amp;ldquo;code&amp;rdquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uses expiration time of accesstoken.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Using gogauth, it will be able to easily use Drive API like &lt;a href=&#34;https://tanaikech.github.io/2017/02/08/file-upload-and-download-with-file-convert-for-curl-using-drive-api/&#34;&gt;this&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can see and download gogauth from &lt;a href=&#34;https://github.com/tanaikech/gogauth&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>File Upload and Download with File Convert For curl using Drive API</title>
      <link>https://tanaikech.github.io/2017/02/08/file-upload-and-download-with-file-convert-for-curl-using-drive-api</link>
      <pubDate>Wed, 08 Feb 2017 15:50:52 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/02/08/file-upload-and-download-with-file-convert-for-curl-using-drive-api</guid>
      <description>

&lt;p&gt;It is necessary to retrieve access token on Google. Scope is as follows.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://www.googleapis.com/auth/drive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other mimetypes can be seen &lt;a href=&#34;https://developers.google.com/drive/v3/web/manage-downloads&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;download-and-convert-from-spreadsheet-to-excel&#34;&gt;Download and convert from Spreadsheet to Excel&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;curl -X GET -sSL \
        -H &amp;quot;Authorization: Bearer [Your access token]&amp;quot; \
        -o &amp;quot;Excel file name&amp;quot; \
        &amp;quot;https://www.googleapis.com/drive/v3/files/[File ID]/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;upload-and-convert-from-excel-to-spreadsheet&#34;&gt;Upload and convert from Excel to Spreadsheet&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST -sSL \
        -H &amp;quot;Authorization: Bearer [Your access token]&amp;quot; \
        -F &amp;quot;metadata={ \
                     name : &#39;[File name on Google Drive]&#39;, \
                     mimeType : &#39;application/vnd.google-apps.spreadsheet&#39; \
                     };type=application/json;charset=UTF-8&amp;quot; \
        -F &amp;quot;file=@[Your Excel file];type=application/vnd.ms-excel&amp;quot; \
        &amp;quot;https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Improved Algorithms for Summation of Array Elements</title>
      <link>https://tanaikech.github.io/2016/10/13/improved-algorithms-for-summation-of-array-elements</link>
      <pubDate>Thu, 13 Oct 2016 14:39:34 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2016/10/13/improved-algorithms-for-summation-of-array-elements</guid>
      <description>

&lt;p&gt;&lt;center&gt;
Kanshi TANAIKE
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;I considered an efficient algorithm for summation of array elements. All elements in an array are string. When those elements are summed using scripts, a standard method is to add each element in order. If the script is run without any optimize, the process becomes gradually sluggish, because the total amount of active data during the summation process is proportional to the square of the number of array elements. This leads directly to the high process-cost. Such phenomenon notably appears at Google Apps Script (GAS). This report says about the solution of this problem using a new algorithm of a pyramid method. The pyramid method achieves that the total amount of active data increases proportional to the linear of the number of array elements. By this, the processing time becomes much shorter than that of the process using the standard method. The pyramid method achieved the process-cost reduction of $99.7\%$ compared with the standard method at GAS. I realized again that new discoveries are hidden into the familiar scenes of every-day life.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;What script comes to mind when you hear the summation of string elements in an array? Most people will probably imagine the method for adding each element in order as following a pseudo code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Declare a string variable arr, sum
    Declare an integer variable loopcounter
    Set arr to size n
    for loopcounter = 0 to (size of arr) - 1
        sum = sum + arr[loopcounter]
        loopcounter = loopcounter + 1
    endfor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It can be said that these are a standard algorithm. When the number of elements is small, this standard method is so useful for the summation. But when the number is large, the summation process becomes sluggish. The reason is that the total amount of active data increases proportionally to the square of the number of array elements. Namely, it means that summing array elements in order leads to high process-cost. High process-cost connects directly to large money and time loss. The summation process is used at variety situations. Recently, the array with string elements are used at the field of big data and, web technology and so on. Therefore, it is very important to design the effective summation algorithms with lower process-cost.&lt;/p&gt;

&lt;p&gt;In this report, an efficient algorithm for summing string elements in an array is introduced. The key factor for this algorithm is to change the total amount of active data during the summation process. At the standard method, the summation process of array elements makes the total amount of active data increase proportionally to the square of number of array elements. On the other hand, at the algorithm in this report, the total amount of active data linearly increases to the number of array elements. This difference is very important for reducing the process cost.&lt;/p&gt;

&lt;p&gt;The primary aim of this report is to reduce the process cost during the summation process. The secondary aim is to reduce the burden for Google when we run the summation process of array elements using Google Apps Script (GAS). GAS is one of good resources which can be used by only browser. It is important to reduce the process cost of GAS by devising. Therefore, the samples which were used in this report were made of GAS. At next section, theoretical approaches will be introduced.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;theoretical-approaches&#34;&gt;Theoretical approaches&lt;/h2&gt;

&lt;p&gt;Array element which is used in this report is string. In order to understand the pyramid method which is introduced in this report, it thinks about the total amount of active data during the summation process. When the array elements are summed by the standard method as shown in Introduce section, the total amount of active data $\Psi$ during the process is&lt;/p&gt;

&lt;p&gt;\[ \Psi = \sum_{\lambda=1}^{\theta} \mu \lambda \tag{1} \]&lt;/p&gt;

&lt;p&gt;where $\mu$ and $\theta$ are the size of one array-element and the number of array elements, respectively.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/efig1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 1: $\Psi$ vs. $\theta$ by Eq.(1).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Figure 1 shows $\Psi$ vs. $\theta$ when $\mu$ is 10 bytes. It is found that $\Psi$ increases proportionally to the square of $\theta$ as shown in Fig.1. I have thought that the processing time has to correlate to the total amount of active data $\Psi$ during the process. In order to reduce $\Psi$, I propose a pyramid method. The pyramid method calculates the sum while dividing $\theta$ to some groups as shown in Fig. 2.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/efig2.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 2: Concept of pyramid method.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;At the pyramid method, the base array without dividing is $\omega=0$ in Fig. 2. At $\omega=1$, $\theta$ is divided to groups by $\phi$ determined as a division number. The array elements in each group is summed. This flow is performed until obtaining the result. As a sample, it shows a pseudo code with the pyramid method at $\omega=1$ obtained from Fig. 2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Declare a string variable arr, tempsum, sum
    Declare an integer variable division, loopcounter1, loopcounter2
    Set arr to size n
    division = d
    for loopcounter1 = division to (size of arr) - 1
        for loopcounter2 = 0 to (size of arr) - 1
            tempsum = tempsum + arr[loopcounter2]
            loopcounter2 = loopcounter2 + 1
        endfor
        sum = sum + tempsum
        tempsum = &#39;&#39;
        loopcounter2 = loopcounter1
        loopcounter1 = loopcounter1 + division
    endfor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When this code is compared to the code at Introduction, it notices that a loop for grouping is added. The array is divided at first loop. The array elements in each group is summed at second loop. When $\omega$ increases, the loops for grouping is increased.&lt;/p&gt;

&lt;p&gt;Here, it considers $\Psi(\omega)$ for Fig. 2. $\Psi(\omega)$ can be expressed as following an equation.&lt;/p&gt;

&lt;p&gt;$ \theta_{\omega} $&lt;/p&gt;

&lt;p&gt;\[ \Psi(\omega) =
\left(\sum_{\lambda=1}^{\phi_1} \mu_{1} \lambda\right)\frac{\theta_{1}}{\phi_{1}} +
\left(\sum_{\lambda=1}^{\phi_2} \mu_{2} \lambda\right)\frac{\theta_{2}}{\phi_{2}} +
 \cdots \]&lt;/p&gt;

&lt;p&gt;\[ + \left(\sum_{\lambda=1}^{\phi_{\omega-1}} \mu_{\omega-1} \lambda\right)\frac{\theta_{\omega-1}}{\phi_{\omega-1}}\]&lt;/p&gt;

&lt;p&gt;\[ + \left\{\left(\sum_{\lambda=1}^{\phi_{\omega}} \mu_{\omega} \lambda\right)\frac{\theta_{\omega}}{\phi_{\omega}} + \sum_{\lambda=1}^{\frac{\theta_{\omega}}{\phi_{\omega}}} \mu_{\omega}\phi_{\omega}\lambda  \right\}
 \tag{2}  \]&lt;/p&gt;

&lt;p&gt;where $\phi$ is a division number. $\theta_{\omega}$ and $\mu_{\omega}$ are $ \theta\phi^{1-\omega} $ and $ \mu\phi^{\omega-1} $, respectively. Equation (2) can be expanded as follows.&lt;/p&gt;

&lt;p&gt;\[ \Psi(\phi, \omega) = \frac{\mu\theta}{2}\left\{ \left(\phi + 3\right)\omega + \frac{\theta}{\phi^{\omega}} - 1 \right\} \tag{3} \]&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/efig3.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 3: $\Psi$($\phi$, $\omega$) vs. $\theta$. $\mu$ and $\phi$ are constant. $\omega$ is changed from 0 to 5.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Figure 3 shows $\Psi(\phi, \omega)$ vs. $\theta$. $\mu$ and $\phi$ are constant. $\omega$ is changed from 0 to 5. A line of $\omega=0$ is same to Fig. 1. From Fig. 3, it is found that $\Psi(\phi, \omega)$ for $\theta$ strongly depends on $\omega$. Also it is found that the change of $\Psi(\phi, \omega)$ approaches the linear increase to $\theta$ with the increase in $\omega$. Then, $\Psi(\phi, \omega)$ becomes small with the increase in $\omega$. It must pay attention that the available $\theta$ changes with the increase in $\omega$. Under $\phi = 10$, when $\omega$ is 2, $\theta$ must be more than 1000. For $\omega=5$, $\theta$ must be more than 1,000,000. The optimized $\phi$ can be obtained by the partial derivative of $\Psi(\phi, \omega)$ with respect to $\phi$ as shown in Eq.(4).&lt;/p&gt;

&lt;p&gt;\[\frac{d\Psi(\phi, \omega)}{d\phi} = \frac{\mu\theta\omega}{2}\left( 1 - \theta \phi^{-(\omega+1)} \right) \tag{4} \]&lt;/p&gt;

&lt;p&gt;When $d\Psi(\phi, \omega)/d\phi$ is 0,&lt;/p&gt;

&lt;p&gt;\[ \phi = \left( \frac{1}{\theta} \right)^{-\frac{1}{\omega+1}} \tag{5} \]&lt;/p&gt;

&lt;p&gt;For example, when $\theta$ and $\omega$ are 1,000,000, 5, respectively, $\phi=10$ is obtained using Eq. (5). The optimized $\omega$ can be obtained by deforming Eq.5 as follows.&lt;/p&gt;

&lt;p&gt;\[ \omega = \log_{\phi} \theta-1 \tag{6} \]&lt;/p&gt;

&lt;p&gt;In order to obtain optimized $\omega$ and $\phi$, either $\omega$ or $\phi$ has to be known. Therefore, at first, it is necessary to decide either $\omega$ or $\phi$. So, $\phi=10$ is used in this study.&lt;/p&gt;

&lt;p&gt;I have already talked that the processing time have to correlate to the total amount of active data $\Psi$ during the process. From theoretical results, the ratio of $\Psi$ for the standard and the pyramid method is 13,514 at $\theta = 1,000,000$. If my estimation is correct, it is considered that the ratio of processing time for the standard and the pyramid method will be large.&lt;/p&gt;

&lt;p&gt;The results of theoretical approaches indicate that the pyramid method is useful for the summation of array elements. At next section, experimental data will show the predominance of pyramid method against the standard method using GAS.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;experimental-results&#34;&gt;Experimental results&lt;/h2&gt;

&lt;p&gt;The sample array used in this study is 2 dimensional array like [[&amp;lsquo;0000000&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], [&amp;lsquo;0000001&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], [&amp;lsquo;0000002&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], ,,,]. When this array is summed, &amp;lsquo;,&amp;rsquo; and &amp;lsquo;\n&amp;rsquo; are added as a delimiter and end code, respectively. The size of an array element $\mu$ is 10 bytes. All array-elements are string.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/efig4n.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 4: Processing time vs. $\theta$ using GAS with standard method.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Figure 4 shows the processing time vs. $\theta$ obtained using the standard method by GAS. This data was obtained using a trigger command of GAS. The actual script can be seen at last section. It was found that the processing time of about 52 minutes are necessary for summing 1,000,000 array elements. Also it was found that the processing time increases proportionally to the square of $\theta$. Also this can be confirmed by the fitting function. This trend in Fig.4 is almost the same to that in Fig. 1. Namely, when the summation process is run, the change of $\Psi$ and the processing time have a correlation. In order to clarify the effect of pyramid method, the processing time vs. $\theta$ using GAS with pyramid method was measured.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/efig5n.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 5: Processing time vs. $\theta$ using GAS with pyramid method.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Figure 5 shows the processing time vs. $\theta$ using GAS with the pyramid method. For the pyramid method, under $\phi=10$, $\omega$ was optimized by the results obtained at the section of Theoretical approaches. Namely, $\omega$ and $\phi$ are changed in accordance with the number of digits of $\theta$. Each data-point was measured 10 times and adopted the average value with error bar. From Fig. 5, it was found that the processing time of the summation process becomes drastically short by adopting the pyramid method. The array elements of 1,000,000 could be summed in about 8 seconds. This is the process-cost reduction of $99.7\%$ compared with Fig. 4. Also it was found that the pyramid method changes the slope of the processing time with the increase in $\theta$ to the linear proportion. This trend corresponds to the prediction at Theoretical approaches. This is indicated that the reduction of the amount of active data during the summation process leads to reducing the process cost. From Figs. 4 and 5, it can be said that the pyramid method is very useful for the summation process with string elements in an array. Furthermore, the pyramid method is easy to apply to the filed of parallel computing. It is considered that the pyramid method can be applied to the parallel computing by giving the summation process of each group to each thread. By this, the efficiency will be much higher.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;I reported about the pyramid method for summing the string elements in an array and obtained following results.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The pyramid method could reduce the process cost of GAS for summing the string elements in an array. In the case of 2 dimensional array used in this study, the pyramid method succeed in the process-cost reduction of $99.7\%$ compared with the standard method. Is this also  Pyramid Power? ;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It was found that the pyramid method is an effectively algorithm for summing the string elements in an array.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It was found that the amount of active data during processing strongly depends on the processing time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It is considered that if the code during running is optimized in any process, the amount of active data during processing dependence on the processing time will be weak. (You can see the report which confirmed this at &lt;a href=&#34;https://tanaikech.github.io/2016/10/13/gas-library---souwa_gas---effects-on-optimized-codes-of-pyramid-method&#34;&gt;here&lt;/a&gt;.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;I would like to thank Google and Google staff.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;appendix&#34;&gt;Appendix&lt;/h2&gt;

&lt;h3 id=&#34;library-for-gas&#34;&gt;Library for GAS&lt;/h3&gt;

&lt;p&gt;A library for GAS using the pyramid method  is &lt;a href=&#34;https://github.com/tanaikech/SOUWA&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;scripts-used-at-this-report&#34;&gt;Scripts used at this report&lt;/h3&gt;

&lt;p&gt;Scripts used at this report are &lt;a href=&#34;https://github.com/tanaikech/SOUWA_test_scripts&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>