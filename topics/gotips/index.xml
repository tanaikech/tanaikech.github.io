<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gotips on tanaike</title>
    <link>https://tanaikech.github.io/topics/gotips/</link>
    <description>Recent content in Gotips on tanaike</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Tue, 23 Oct 2018 16:59:51 +0900</lastBuildDate>
    
	<atom:link href="https://tanaikech.github.io/topics/gotips/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Zip Compression of Downloaded File using Golang</title>
      <link>https://tanaikech.github.io/2018/10/23/zip-compression-of-downloaded-file-using-golang/</link>
      <pubDate>Tue, 23 Oct 2018 16:59:51 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2018/10/23/zip-compression-of-downloaded-file-using-golang/</guid>
      <description>Gists
This is a sample script for creating a downloaded file as a zip file using Golang. The downloaded file is not created to a file as a temporal file. The zip file is directly created. When you use this, please modify url, downloadedFileName and zipFileName.
Sample script: package main import ( &amp;quot;archive/zip&amp;quot; &amp;quot;bytes&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;io&amp;quot; &amp;quot;io/ioutil&amp;quot; &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;os&amp;quot; &amp;quot;time&amp;quot; ) func main() { url := &amp;quot;https://localhost/sample.png&amp;quot; downloadedFileName := &amp;quot;sample.</description>
    </item>
    
    <item>
      <title>Transposing Slice From (n x m) To (m x n) for golang</title>
      <link>https://tanaikech.github.io/2018/02/22/transposing-slice-from-n-x-m-to-m-x-n-for-golang/</link>
      <pubDate>Thu, 22 Feb 2018 11:25:43 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2018/02/22/transposing-slice-from-n-x-m-to-m-x-n-for-golang/</guid>
      <description>Gists
This is a sample script for transposing slice from (n x m) to (m x n) for golang.
Script : package main import &amp;quot;fmt&amp;quot; func transpose(slice [][]string) [][]string { xl := len(slice[0]) yl := len(slice) result := make([][]string, xl) for i := range result { result[i] = make([]string, yl) } for i := 0; i &amp;lt; xl; i++ { for j := 0; j &amp;lt; yl; j++ { result[i][j] = slice[j][i] } } return result } func main() { sample := [][]string{ []string{&amp;quot;a1&amp;quot;, &amp;quot;a2&amp;quot;, &amp;quot;a3&amp;quot;, &amp;quot;a4&amp;quot;, &amp;quot;a5&amp;quot;}, []string{&amp;quot;b1&amp;quot;, &amp;quot;b2&amp;quot;, &amp;quot;b3&amp;quot;, &amp;quot;b4&amp;quot;, &amp;quot;b5&amp;quot;}, []string{&amp;quot;c1&amp;quot;, &amp;quot;c2&amp;quot;, &amp;quot;c3&amp;quot;, &amp;quot;c4&amp;quot;, &amp;quot;c5&amp;quot;}, } ar := transpose(sample) fmt.</description>
    </item>
    
    <item>
      <title>Copying Values from JSON to Struct using reflect Package</title>
      <link>https://tanaikech.github.io/2018/02/06/copying-values-from-json-to-struct-using-reflect-package/</link>
      <pubDate>Tue, 06 Feb 2018 10:22:55 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2018/02/06/copying-values-from-json-to-struct-using-reflect-package/</guid>
      <description>Gists
This is a sample script for copying values from JSON to a struct using reflect package.
Script : package main import ( &amp;quot;encoding/json&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;reflect&amp;quot; ) type obj struct { Key1 string `json:&amp;quot;k1&amp;quot;` Key2 string `json:&amp;quot;k2&amp;quot;` Key3 int64 `json:&amp;quot;k3&amp;quot;` Key4 int `json:&amp;quot;k4&amp;quot;` Key5 bool `json:&amp;quot;k5&amp;quot;` } func main() { data := `{&amp;quot;k1&amp;quot;: &amp;quot;v1&amp;quot;, &amp;quot;k2&amp;quot;: &amp;quot;v2&amp;quot;, &amp;quot;k3&amp;quot;: 1234567890, &amp;quot;k4&amp;quot;: 456, &amp;quot;k5&amp;quot;: true}` d := map[string]interface{}{} json.Unmarshal([]byte(data), &amp;amp;d) obj := &amp;amp;obj{} s := reflect.</description>
    </item>
    
    <item>
      <title>Parsing JSON object (keys are number and changing every time)</title>
      <link>https://tanaikech.github.io/2018/02/05/parsing-json-object-keys-are-number-and-changing-every-time/</link>
      <pubDate>Mon, 05 Feb 2018 13:25:03 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2018/02/05/parsing-json-object-keys-are-number-and-changing-every-time/</guid>
      <description>Gists
This sample script is for parsing JSON object. In the object, the keys are number and changing every time.
Object : { &amp;quot;key1&amp;quot;: { &amp;quot;key2&amp;quot;: [ {&amp;quot;0&amp;quot;: [{&amp;quot;key3&amp;quot;: &amp;quot;value3a&amp;quot;}, {&amp;quot;key3&amp;quot;: &amp;quot;value3b&amp;quot;}]}, {&amp;quot;1&amp;quot;: [{&amp;quot;key3&amp;quot;: &amp;quot;value3c&amp;quot;}, {&amp;quot;key3&amp;quot;: &amp;quot;value3d&amp;quot;}]} ] } }  Script : package main import ( &amp;quot;encoding/json&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;strconv&amp;quot; ) type key1 struct { Key1 key2 `json:&amp;quot;key1&amp;quot;` } type key2 struct { Key2 []interface{} `json:&amp;quot;key2&amp;quot;` } func main() { data := `{&amp;quot;key1&amp;quot;: {&amp;quot;key2&amp;quot;: [{&amp;quot;0&amp;quot;: [{&amp;quot;key3&amp;quot;: &amp;quot;value3a&amp;quot;}, {&amp;quot;key3&amp;quot;: &amp;quot;value3b&amp;quot;}]},{&amp;quot;1&amp;quot;: [{&amp;quot;key3&amp;quot;: &amp;quot;value3c&amp;quot;}, {&amp;quot;key3&amp;quot;: &amp;quot;value3d&amp;quot;}]}]}}` k1 := &amp;amp;key1{} json.</description>
    </item>
    
    <item>
      <title>Uploading CSV File as Spreadsheet and Modifying Permissions using Golang</title>
      <link>https://tanaikech.github.io/2017/09/21/uploading-csv-file-as-spreadsheet-and-modifying-permissions-using-golang/</link>
      <pubDate>Thu, 21 Sep 2017 15:43:14 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/09/21/uploading-csv-file-as-spreadsheet-and-modifying-permissions-using-golang/</guid>
      <description>Gists
This sample script is for uploading CSV file as Spreadsheet and modifying permissions using Golang.
I think that the detail information of google-api-go-client is a bit little. The sample scripts are so little. It retrieves most information from only godoc and GitHub. So I publish such sample scripts here. If this is useful for you, I&amp;rsquo;m glad.
Important points :  Give mimeType of file that it wants to upload to options of Media(r io.</description>
    </item>
    
    <item>
      <title>spreadsheets.values.batchUpdate using Golang</title>
      <link>https://tanaikech.github.io/2017/09/15/spreadsheets.values.batchupdate-using-golang/</link>
      <pubDate>Fri, 15 Sep 2017 14:14:50 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/09/15/spreadsheets.values.batchupdate-using-golang/</guid>
      <description>Gists
Flow : In my sample script, the script was made using the Quickstart. The flow to use this sample script is as follows.
 For Go Quickstart, please do Step 1 and Step 2. Please put client_secret.json to the same directory with my sample script. Copy and paste my sample script, and create it as new script file. Run the script. When Go to the following link in your browser then type the authorization code: is shown on your terminal, please copy the URL and paste to your browser.</description>
    </item>
    
    <item>
      <title>Exporting Project on Google Drive using Golang Quickstart</title>
      <link>https://tanaikech.github.io/2017/08/27/exporting-project-on-google-drive-using-golang-quickstart/</link>
      <pubDate>Sun, 27 Aug 2017 12:01:58 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/08/27/exporting-project-on-google-drive-using-golang-quickstart/</guid>
      <description>Gists
This is a sample script for exporting a project on Google Drive to local PC using Golang Quickstart. A file with refresh token is saved to the same directory with this script as go-quickstart.json. Before you run this script, please enable Drive API on your Google API console.
Points for exporting project  In order to export project, both drive.DriveScriptsScope and drive.DriveScope have to be included in the scope.</description>
    </item>
    
    <item>
      <title>Go Library - getcode</title>
      <link>https://tanaikech.github.io/2017/06/21/go-library---getcode/</link>
      <pubDate>Wed, 21 Jun 2017 14:17:39 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/21/go-library---getcode/</guid>
      <description>Overview This is a Golang library to automatically get an authorization code for retrieving access token using OAuth2.
Description When it retrieves an access token and refresh token using OAuth2, the code for retrieving them has to be got by authorization on own browser. In order to retrieve the code, in generally, users have to click the authorization button and copy the code on the browser. This library can be automatically got the code by launching HTML server as a redirected server.</description>
    </item>
    
    <item>
      <title>Benchmark: Retrieving Values from Deep Nested JSON at Golang</title>
      <link>https://tanaikech.github.io/2017/06/17/benchmark-retrieving-values-from-deep-nested-json-at-golang/</link>
      <pubDate>Sat, 17 Jun 2017 10:06:24 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/17/benchmark-retrieving-values-from-deep-nested-json-at-golang/</guid>
      <description>This sample script is for retrieving values from a deep nested JSON. There are 2 patterns. So for these, the benchmark were measured.
Script : package main import ( &amp;quot;encoding/json&amp;quot; &amp;quot;testing&amp;quot; ) const ( data = `{ &amp;quot;A_key1&amp;quot;: { &amp;quot;B_key1&amp;quot;: { &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot; } } }` ) func BenchmarkB1(b *testing.B) { b.ResetTimer() for i := 0; i &amp;lt; b.N; i++ { var p map[string]interface{} json.Unmarshal([]byte(data), &amp;amp;p) a1 := p[&amp;quot;A_key1&amp;quot;] a2 := p[&amp;quot;A_key1&amp;quot;].</description>
    </item>
    
    <item>
      <title>Slice Created by Split at Golang</title>
      <link>https://tanaikech.github.io/2017/06/09/slice-created-by-split-at-golang/</link>
      <pubDate>Fri, 09 Jun 2017 09:16:56 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/09/slice-created-by-split-at-golang/</guid>
      <description>When a string without no strings is split by strings.Split(), the created slice is the same to the slice created by make(). The length of the slice doesn&amp;rsquo;t become zero.
Sample script : package main import ( &amp;quot;fmt&amp;quot; &amp;quot;strings&amp;quot; ) func main() { sample1a := strings.Split(&amp;quot;&amp;quot;, &amp;quot; &amp;quot;) fmt.Printf(&amp;quot;%v, %v, &#39;%v&#39;, %v, %+q\n&amp;quot;, sample1a, len(sample1a), sample1a[0], len(sample1a[0]), sample1a[0]) sample1b := make([]string, 1) fmt.Printf(&amp;quot;%v, %v, &#39;%v&#39;, %v, %+q\n&amp;quot;, sample1b, len(sample1b), sample1b[0], len(sample1b[0]), sample1b[0]) var sample2a []string fmt.</description>
    </item>
    
    <item>
      <title>Changing from &#39;float64&#39; to &#39;int&#39; for Values did Unmarshal using &#39;map[string]interface{}&#39;</title>
      <link>https://tanaikech.github.io/2017/06/02/changing-from-float64-to-int-for-values-did-unmarshal-using-mapstringinterface/</link>
      <pubDate>Fri, 02 Jun 2017 17:22:13 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/02/changing-from-float64-to-int-for-values-did-unmarshal-using-mapstringinterface/</guid>
      <description>This sample is for changing from &amp;ldquo;float64&amp;rdquo; to &amp;ldquo;int&amp;rdquo; for values did unmarshal using map[string]interface{}.
When it did unmarshal using map[string]interface{}, a number with &amp;ldquo;int&amp;rdquo; was changed to &amp;ldquo;float64&amp;rdquo;. And it shows an error as follows.
Error :
panic: interface conversion: interface {} is float64, not int  Sample Script : It solves using following script.
package main import ( &amp;quot;encoding/json&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;reflect&amp;quot; ) func main() { data := `{&amp;quot;key&amp;quot;: 10}` var i map[string]interface{} json.</description>
    </item>
    
    <item>
      <title>Replacing JSON Key by Golang</title>
      <link>https://tanaikech.github.io/2017/06/02/replacing-json-key-by-golang/</link>
      <pubDate>Fri, 02 Jun 2017 11:56:30 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/02/replacing-json-key-by-golang/</guid>
      <description>This sample is for replacing JSON key by golang.
package main import ( &amp;quot;encoding/json&amp;quot; &amp;quot;fmt&amp;quot; ) func main() { json1 := `{&amp;quot;key1&amp;quot;: &amp;quot;value1&amp;quot;}` obj := map[string]interface{}{} json.Unmarshal([]byte(json1), &amp;amp;obj) fmt.Println(obj) // &amp;lt;-- map[key1:value1] obj[&amp;quot;key2&amp;quot;] = obj[&amp;quot;key1&amp;quot;] delete(obj, &amp;quot;key1&amp;quot;) fmt.Println(obj) // &amp;lt;-- map[key2:value1] }  </description>
    </item>
    
    <item>
      <title>Benchmark: Splitting Command-Line Arguments by Golang</title>
      <link>https://tanaikech.github.io/2017/06/02/benchmark-splitting-command-line-arguments-by-golang/</link>
      <pubDate>Fri, 02 Jun 2017 10:59:31 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/02/benchmark-splitting-command-line-arguments-by-golang/</guid>
      <description>This sample script is for splitting command-line arguments by golang. There are 2 types. One is the regular expression is used. Another is that Split() and TrimSpace() are used.
Here, each process speed was compared.
Script : package main import ( &amp;quot;regexp&amp;quot; &amp;quot;strings&amp;quot; &amp;quot;testing&amp;quot; ) func BenchmarkB1(b *testing.B) { str := &amp;quot;test1.txt, test2.txt&amp;quot; b.ResetTimer() for i := 0; i &amp;lt; b.N; i++ { ar := regexp.MustCompile(`\s*,\s*`).Split(str, -1) var result []string for _, x := range ar { result = append(result, x) // --&amp;gt; &#39;test.</description>
    </item>
    
    <item>
      <title>Decoding JSON by Golang</title>
      <link>https://tanaikech.github.io/2017/05/21/decoding-json-by-golang/</link>
      <pubDate>Sun, 21 May 2017 11:55:34 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/05/21/decoding-json-by-golang/</guid>
      <description>Decoding JSON by Golang
func main() { data := `{ &amp;quot;A_key1&amp;quot;: { &amp;quot;B_key1&amp;quot;: { &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot; } }, &amp;quot;A_key2&amp;quot;: { &amp;quot;B_key2&amp;quot;: { &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot; } }, &amp;quot;A_key3&amp;quot;: { &amp;quot;B_key3&amp;quot;: { &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot; } }, &amp;quot;A_key4&amp;quot;: { &amp;quot;B_key4&amp;quot;: { &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot; } }, &amp;quot;A_key5&amp;quot;: { &amp;quot;B_key5&amp;quot;: { &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot; } } }` var p interface{} json.NewDecoder(strings.NewReader(data)).Decode(&amp;amp;p) fmt.Println(p) }  Go Playground</description>
    </item>
    
    <item>
      <title>Dynamically Creating JSON by Golang</title>
      <link>https://tanaikech.github.io/2017/05/21/dynamically-creating-json-by-golang/</link>
      <pubDate>Sun, 21 May 2017 10:55:35 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/05/21/dynamically-creating-json-by-golang/</guid>
      <description>Dynamically Creating JSON by Golang
obj := map[string]interface{}{} obj[&amp;quot;hoge&amp;quot;] = &amp;quot;huga&amp;quot; fmt.Println(obj)  Go Playground</description>
    </item>
    
    <item>
      <title>Retrieving Response Headers by Golang</title>
      <link>https://tanaikech.github.io/2017/05/21/retrieving-response-headers-by-golang/</link>
      <pubDate>Sun, 21 May 2017 10:43:32 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/05/21/retrieving-response-headers-by-golang/</guid>
      <description>Retrieving Response Headers by Golang
res, _ := client.Do(req) contentType := res.Header.Get(&amp;quot;Content-Type&amp;quot;) contentLength := res.Header.Get(&amp;quot;Content-Length&amp;quot;)  </description>
    </item>
    
    <item>
      <title>Dynamical Nested JSON Objects by Golang</title>
      <link>https://tanaikech.github.io/2017/05/09/dynamical-nested-json-objects-by-golang/</link>
      <pubDate>Tue, 09 May 2017 15:58:08 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/05/09/dynamical-nested-json-objects-by-golang/</guid>
      <description> This sample script dynamically creates nested JSON objects.
Script obj := map[string]interface{}{} for i := 1; i &amp;lt;= 5; i++ { value := map[string]interface{}{ fmt.Sprintf(&amp;quot;B_key%d&amp;quot;, i): map[string]interface{}{ &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot;, }, } obj[fmt.Sprintf(&amp;quot;A_key%d&amp;quot;, i)] = value }  Result { &amp;quot;A_key1&amp;quot;: { &amp;quot;B_key1&amp;quot;: { &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot; } }, &amp;quot;A_key2&amp;quot;: { &amp;quot;B_key2&amp;quot;: { &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot; } }, &amp;quot;A_key3&amp;quot;: { &amp;quot;B_key3&amp;quot;: { &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot; } }, &amp;quot;A_key4&amp;quot;: { &amp;quot;B_key4&amp;quot;: { &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot; } }, &amp;quot;A_key5&amp;quot;: { &amp;quot;B_key5&amp;quot;: { &amp;quot;C_key&amp;quot;: &amp;quot;value&amp;quot; } } }  </description>
    </item>
    
    <item>
      <title>Put a channel to a channel for golang</title>
      <link>https://tanaikech.github.io/2017/03/29/put-a-channel-to-a-channel-for-golang/</link>
      <pubDate>Wed, 29 Mar 2017 07:53:51 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/03/29/put-a-channel-to-a-channel-for-golang/</guid>
      <description>I have never heard this. I would like to use this from now.
package main import &amp;quot;fmt&amp;quot; type st struct { data1 int data2 int } func main() { c1 := make(chan *st, 1) c2 := make(chan *st, 1) c1 &amp;lt;- &amp;amp;st{1, 2} c2 &amp;lt;- &amp;lt;-c1 close(c1) close(c2) res, _ := &amp;lt;-c2 fmt.Println(res.data2) } &amp;gt;&amp;gt;&amp;gt; 2  </description>
    </item>
    
  </channel>
</rss>