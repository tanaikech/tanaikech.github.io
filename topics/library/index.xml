<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Library on tanaike</title>
    <link>https://tanaikech.github.io/topics/library/</link>
    <description>Recent content in Library on tanaike</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Thu, 29 Jun 2017 16:09:57 +0900</lastBuildDate>
    <atom:link href="https://tanaikech.github.io/topics/library/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Updated: GAS Library - ImgApp</title>
      <link>https://tanaikech.github.io/2017/06/29/updated-gas-library---imgapp</link>
      <pubDate>Thu, 29 Jun 2017 16:09:57 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/29/updated-gas-library---imgapp</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/tanaikech/ImgApp&#34;&gt;ImgApp&lt;/a&gt; was updated to v1.1.0. New method was added.&lt;/p&gt;

&lt;h2 id=&#34;2-doresize&#34;&gt;2. doResize()&lt;/h2&gt;

&lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;

&lt;p&gt;This method is for resizing images.&lt;/p&gt;

&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;

&lt;p&gt;Unfortunately, there are no methods to resize images at Google Apps Script. As a workaround, there is a method that it imports the image in Google Document and resizes the image using &lt;code&gt;setWidth()&lt;/code&gt; and &lt;code&gt;setHeight()&lt;/code&gt;. But in this method, the resized blob cannot be retrieved. So although I had thought of other workaround, I had not been able to find it. Recently, I accidentally discovered the other workaround &lt;code&gt;doResize()&lt;/code&gt;. Since it was found that this workaround can be surely used, I added this to ImgApp.&lt;/p&gt;

&lt;h3 id=&#34;demo&#34;&gt;Demo&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/tanaikech/ImgApp/raw/master/images/demo2.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is a demonstration for this method. As a sample. at first, the size of source image is retrieved using &lt;code&gt;getSize()&lt;/code&gt;. Then, the source image is resized by the inputted width. &lt;strong&gt;The play speed is the real time.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This sample image is created by &lt;a href=&#34;http://k3-studio.deviantart.com/art/Chromatic-lituus-415318548&#34;&gt;k3-studio&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You can see the detail information here &lt;a href=&#34;https://github.com/tanaikech/ImgApp&#34;&gt;https://github.com/tanaikech/ImgApp&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GAS Library - ImgApp - getSize()</title>
      <link>https://tanaikech.github.io/2017/06/27/gas-library---imgapp---getsize</link>
      <pubDate>Tue, 27 Jun 2017 16:21:52 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/27/gas-library---imgapp---getsize</guid>
      <description>

&lt;h2 id=&#34;1-getsize&#34;&gt;1. getSize()&lt;/h2&gt;

&lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;

&lt;p&gt;This method is for retrieving the width and height of image as the unit of pixel.&lt;/p&gt;

&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;

&lt;p&gt;Unfortunately, there are no methods to directly retrieve the image size at Google Apps Script. As a workaround, there is a method that it imports the image in Google Document and retrieves the size using &lt;code&gt;getWidth()&lt;/code&gt; and &lt;code&gt;getHeight()&lt;/code&gt;. But in this method, it uses much time and resources on Google. So I thought of retrieving the information of image at the binary level, and created this. By this, the low process cost could be achieved.&lt;/p&gt;

&lt;h3 id=&#34;demo&#34;&gt;Demo&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/tanaikech/ImgApp/raw/master/images/demo1.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is a demonstration for this method. the size information is retrieved from BMP, GIF, PNG and JPG files. The play speed is the real time. From this demo, you can see the speed for retrieving the size information from files.&lt;/p&gt;

&lt;p&gt;This sample image is created by &lt;a href=&#34;http://k3-studio.deviantart.com/art/Overpass-413875385&#34;&gt;k3-studio&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You can see the detail information here &lt;a href=&#34;https://github.com/tanaikech/ImgApp&#34;&gt;https://github.com/tanaikech/ImgApp&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Library - getcode</title>
      <link>https://tanaikech.github.io/2017/06/21/go-library---getcode</link>
      <pubDate>Wed, 21 Jun 2017 14:17:39 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/21/go-library---getcode</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;This is a Golang library to automatically get an authorization code for retrieving access token using OAuth2.&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;When it retrieves an access token and refresh token using OAuth2, the code for retrieving them has to be got by authorization on own browser. In order to retrieve the code, in generally, users have to click the authorization button and copy the code on the browser. This library can be automatically got the code by launching HTML server as a redirected server. At first, I have used this for retrieving the code from Google. But recently I noticed that this can be used for other sites. They are Google, GitHub, Slack and so on. This library can be used for creating such applications.&lt;/p&gt;

&lt;p&gt;This method was used for gogauth. Next, it was used for ggsrun And, this was recreated as a library.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You can get this from &lt;a href=&#34;https://github.com/tanaikech/getcode&#34;&gt;https://github.com/tanaikech/getcode&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Updated: GAS Library - SOUWA</title>
      <link>https://tanaikech.github.io/2017/06/19/updated-gas-library---souwa</link>
      <pubDate>Mon, 19 Jun 2017 07:06:45 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/06/19/updated-gas-library---souwa</guid>
      <description>&lt;p&gt;SOUWA means summing in Japanese. SOUWA can sum string elements in an array at the high speed. The speed of SOUWA with &lt;strong&gt;the pyramid algorithm is about 380 times faster than that of the standard method&lt;/strong&gt;. New algorithm for summing array elements was developed for SOUWA. You can see the detailed report of this library at here. If you are interested in this, I&amp;rsquo;m glad.&lt;/p&gt;

&lt;p&gt;It was updated to v1.0.2. Please check it out. &lt;a href=&#34;https://github.com/tanaikech/SOUWA_GAS&#34;&gt;https://github.com/tanaikech/SOUWA_GAS&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GAS Library - CreateImg</title>
      <link>https://tanaikech.github.io/2017/04/17/gas-library---createimg</link>
      <pubDate>Mon, 17 Apr 2017 15:29:15 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2017/04/17/gas-library---createimg</guid>
      <description>&lt;p&gt;Recently, I had been looking for creating an image from coordinate data. Unfortunately I have never found them. So I made this. This Google Apps Script (GAS) library creates an image file from coordinate data.&lt;/p&gt;

&lt;p&gt;You can see the detail information at &lt;a href=&#34;https://github.com/tanaikech/CreateImg&#34;&gt;https://github.com/tanaikech/CreateImg&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There is a part where I would like to improve in this library. That&amp;rsquo;s &lt;code&gt;convByteSlice()&lt;/code&gt;. I think that there is the method to be faster about the part. If you know much about the logical operation using GAS, if you teach me about the improvements. I&amp;rsquo;m so glad.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python Library - souwapy</title>
      <link>https://tanaikech.github.io/2016/10/30/python-library---souwapy</link>
      <pubDate>Sun, 30 Oct 2016 13:38:29 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2016/10/30/python-library---souwapy</guid>
      <description>&lt;p&gt;This &amp;ldquo;souwapy&amp;rdquo; is a library for summing array elements with high speed by new algorithm (&lt;a href=&#34;https://tanaikech.github.io/2016/10/13/improved-algorithms-for-summation-of-array-elements/&#34;&gt;Pyramid method&lt;/a&gt;). The speed is faster than csv and panbdas module of python and v8 engine of node.js. The souwapy module is 2.3 and 3.1 times faster than csv and pandas module, respectively. This was really surprised me. It was found that the theory was correct.&lt;/p&gt;

&lt;p&gt;At first, I have created this theory for Google Apps Script. But recently I had to use large data and output a csv file on python. So I made this library. Additionally, I had wanted to know how to public own library to PyPI before. This chance was good for me. If this library is helpful for other people, I&amp;rsquo;m glad.&lt;/p&gt;

&lt;p&gt;The detailed information of souwapy is as follows. You can know how to install and use this library.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;PyPI &amp;ndash;&amp;gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://pypi.python.org/pypi/souwapy&#34;&gt;https://pypi.python.org/pypi/souwapy&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;GitHub &amp;ndash;&amp;gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/tanaikech/souwapy&#34;&gt;https://github.com/tanaikech/souwapy&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>GAS Library - SOUWA_GAS - Effects on Optimized Codes of Pyramid Method</title>
      <link>https://tanaikech.github.io/2016/10/13/gas-library---souwa_gas---effects-on-optimized-codes-of-pyramid-method</link>
      <pubDate>Thu, 13 Oct 2016 15:57:20 +0900</pubDate>
      
      <guid>https://tanaikech.github.io/2016/10/13/gas-library---souwa_gas---effects-on-optimized-codes-of-pyramid-method</guid>
      <description>

&lt;p&gt;&lt;center&gt;
Kanshi TANAIKE
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;#ref1&#34;&gt;I have already reported that the pyramid method is one of very effectively algolithms for summing string elements in an array using Google Apps Script (GAS).&lt;/a&gt; This report describes the adaptability of the pyramid method to any languages except for GAS. c++ (g++), Go, Java, Javascript on Node.js, Python and Ruby were chosen as the sample languages. In those languages, there are languages which have the distinctive commands for summing the array elements. In this report, &amp;ldquo;+&amp;rdquo; operator as a standard command and a special command for each language were used. For c++ (g++), Javascript on Node.js and Python which have no distinctive commands for summing the array elements, only &amp;ldquo;+&amp;rdquo; operator was used. For others, both &amp;ldquo;+&amp;rdquo; operator and each special command such as &amp;ldquo;[]byte&amp;rdquo;, &amp;ldquo;StringBuilder&amp;rdquo; and &amp;ldquo;&amp;lt;&amp;lt;&amp;rdquo; were used. For languages without the distinctive commands for summing, the pyramid method made us show some interesting phenomena. It was found that the pyramid method shows a good effect on only the specific language. It was found that &amp;ldquo;+&amp;rdquo; operator had been optimized for g++ and Node.js. &amp;ldquo;+&amp;rdquo; operator of Python was corresponding to theoretical results. This means that &amp;ldquo;+&amp;rdquo; operator of Python is not optimized. On the other hand, for languages with the distinctive commands for summing, it was found that the distinctive commands is incompatible to the pyramid method. These results made us show the possibility of visualization for the optimized codes.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;When the string elements in an array are summed by a script, there are various patterns for each language. A standard algorithm is the method using &amp;ldquo;+&amp;rdquo; operator as following a pseudo code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Declare a string variable arr, sum
    Declare an integer variable loopcounter
    Set arr to size n
    for loopcounter = 0 to (size of arr) - 1
        sum = sum + arr[loopcounter]
        loopcounter = loopcounter + 1
    endfor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some languages have the special commands (&amp;rdquo;[]byte&amp;rdquo;, &amp;ldquo;StringBuilder&amp;rdquo; and &amp;ldquo;&amp;lt;&amp;lt;&amp;ldquo;) for summing string elements except for &amp;ldquo;+&amp;rdquo; operator. Such languages can sum elements effectively using the special commands even if the standard method was used. However the languages which have no special commands must use only &amp;ldquo;+&amp;rdquo; operator. I had experienced that at GAS. Therefore, I have proposed the pyramid method. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;] It had been found that the pyramid method is high efficiency for summing the array elements at GAS. It is very important for today, which have increased the opportunity to handle the strings, to efficiently sum the strings. In this report, I have investigated about the adaptability of pyramid method to any languages.&lt;/p&gt;

&lt;p&gt;Now I have 2 patterns of the standard method and the pyramid method for summing array elements. Furthermore, those 2 patterns were demonstrated by experimental and theoretical approaches. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;] I have thought that the optimization of each language may be able to be evaluated using as those tools. In this study, those tools made us show some interesting phenomena. The pyramid method showed a good effect on only the specific language using &amp;ldquo;+&amp;rdquo; operator. It was found that the languages which showed no good effect had had the optimized &amp;ldquo;+&amp;rdquo; operator. It is considered that this is due to the optimization engine of interpreters and compilers. It was found that the languages with the special commands for summing array elements are incompatible to the pyramid method. These results say that the languages with &amp;ldquo;+&amp;rdquo; operator without the optimization can benefit from the pyramid method. Also it is considered that the pyramid method can be used to evaluate the optimization engine. The result in this study gave us the possibility of visualization for optimized codes. So there are two aims of this report. One is to confirm the effects on various languages of the pyramid methods. And another is to consider the visualization of optimization engine.&lt;/p&gt;

&lt;p&gt;For the detailed information of the standard method and the pyramid method which are used in this report, you can see them. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;experimental-procedure&#34;&gt;Experimental procedure&lt;/h2&gt;

&lt;p&gt;$\Psi, \mu, \theta, \phi$ and $\omega$ which are used in this report are the total amount of active data during the summing process, the size of one array-element, the number of total array elements, the size of division for dividing array and the number of divisions for the pyramid method, respectively. The detailed information of them are &lt;a href=&#34;#ref1&#34;&gt;here&lt;/a&gt;. The array used in this study is 2 dimensional array constructed with strings such as [[&amp;lsquo;0000000&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], [&amp;lsquo;0000001&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], [&amp;lsquo;0000002&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], ,,,]. When this array is summed, &amp;lsquo;,&amp;rsquo; and &amp;lsquo;\n&amp;rsquo; are added as a delimiter and an end code, respectively. So the size of an element $\mu$ becomes 10 bytes. The optimized $\omega$ and $\phi$ were obtained by report [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;]. Those are $\omega=\log_{10} \theta - 1, \phi=(1/\theta)^{-1/(\omega+1)}$. The languages which were chosen for this study are shown in table 1. c++ sources were compiled by g++ (6.1.0 on msys2) with the option &amp;ldquo;-O2&amp;rdquo;. The PC spec which was used for measuring data in this study is CPU Core i5-3210M, Memory 8 GB, OS Windows10 (x64) (v1607).&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Table 1: Languages used in this study.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Language&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;c++&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;Compiler g++ (6.1.0 on msys2)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Go&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v1.7.1 windows/amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v8 (1.8.0_101)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Javascript on Node.js&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v6.3.0 (v8 &amp;lsquo;5.0.71.52&amp;rsquo;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Python&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v3.5.2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Ruby&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;v2.3.1p112&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;results-and-discussions&#34;&gt;Results and discussions&lt;/h2&gt;

&lt;p&gt;Figures 1 - 6 show the behavior of the processing time for each language with the increase in $\theta$ which is the number of array elements. All figures were put in a table. Left side shows the results taken from the measurements using &amp;ldquo;+&amp;rdquo; operator. Right side shows the results taken from the measurements using the distinctive commands of each language.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/gpp1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 1: g++ using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/node1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 2: Javascript on Node.js using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/py1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 3: Python using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/go1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/go2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 4(a): Go using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 4(b): Go using &amp;ldquo;[]byte&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/go2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 4(c): Go using &amp;ldquo;[]byte&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/java1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/java2.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 5(a): Java using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 5(b): Java using &amp;ldquo;StringBuilder&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/ruby1.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/ruby2.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 6(a): Ruby using &amp;ldquo;+&amp;rdquo;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 6(b): Ruby using &amp;ldquo;&amp;lt;&amp;lt;&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;g++, Node.js and Python in Figs. 1 - 3 have no distinctive commands except for &amp;ldquo;+&amp;rdquo; operator. Go, Java and Ruby in Figs. 4 - 6 have distinctive commands. For the results of &amp;ldquo;+&amp;rdquo; operator, the language except for g++ and Node.js can be confirmed the effect of the pyramid method. Especially, Python and Ruby in Figs. 3 and 6(a) show the behavior corresponding to theoretical results which had been already reported by me. [&lt;a href=&#34;#ref1&#34;&gt;1&lt;/a&gt;] For the standard method, $\Psi$, which is the total amount of active data during summing, increases proportionally to the square of $\theta$. For the pyramid method, $\Psi$ linearly increases with the increase in $\theta$. Go and Java in Figs. 4(a) and 5(a) show the increase of $\Psi$ proportionally to the square of $\theta$ for both red and blue lines. The optimization may influence to the process of pyramid method. g++ and Node.js in Figs. 1 and 2 show no effect of the pyramid method. It is considered that &amp;ldquo;+&amp;rdquo; operator is optimized for g++ and Node.js which have no special commands for summing array elements. V8 engine of Node.js is known as one of the optimization engines. The optimization may influence to only the standard method or disturb the work of pyramid method. For Go, Java and Ruby which have the special commands for summing, the pyramid method shows no effect as shown in Figs. 4(b), 4(c), 5(b) and 6(b). Also it is considered that this is due to the optimization. In Figs. 1, 2, 4(b), 5(b) and 6(b), $\Psi$ linearly increases with the increase in $\theta$ for the standard method. Furthermore, the reverse phenomenon that the process speed of standard method becomes faster than that of pyramid method occurs in those figures. These clearly show the optimization of summing process. In order to consider these, it thinks of the number of loops during summing process. The number of loops $N_{l}$ during summing process can be expressed as follows.&lt;/p&gt;

&lt;p&gt;\[ N_{l} = \sum_{k=1}^{\omega - 1} \frac{\theta}{\phi^{k}} \tag{1} \]&lt;/p&gt;

&lt;p&gt;From Eq. (1), $N_{l0} = \theta$ at $\omega=0$ and $N_{li} = \theta(1 - \phi^{-1})^{-1}$ at $\omega=\infty$ can be obtained. Therefore, the increasing rate $\varepsilon$ from $N_{l0}$ to $N_{li}$ becomes as follows.&lt;/p&gt;

&lt;p&gt;\[ \varepsilon = 100 \times \frac{1}{(\phi - 1)} \tag{2} \]&lt;/p&gt;

&lt;p&gt;where the unit is $\%$. $\omega = 0$ and $\omega \geqq 1$ mean the standard and the pyramid method, respectively. Here, since this study was performed under the condition of $\theta = 1,000,000$ and $\phi = 10$, $\varepsilon$ is $11\%$ and the number of loops of the pyramid method increases 11,000 for that of the standard method under this condition. In this study, the number of loops for the pyramid method is $11\%$ larger than that of the standard method. Then, I think that when the languages for summing process are optimized, the search of last address of each string is much faster than that of languages without the optimization. By these, when the languages have the special commands for summing array elements and the optimized &amp;ldquo;+&amp;rdquo; operator, it is considered that the processing time strongly depends on the number of loops in the code rather than $\Psi$. Therefore, it is considered that the reverse phenomenon occurs for the processing time between the standard and the pyramid method as shown in Figs. 1, 2, 5(b) and 6(b). And the reverse phenomenon is remarkable, since the speed of g++ is much faster than that of other languages.&lt;/p&gt;

&lt;p&gt;Here, when Figs. 2 and 6(b) are compared, it is found that both behaviors of $\Psi$ for the increase in $\theta$ are almost the same. At $\theta = 1,000,000$ of the standard method, the processing time is 1.13 s and 1.25 s for Node.js and Ruby, respectively. It may indicate that both optimization is almost the same.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://tanaikech.github.io/img/rank.png&#34; alt=&#34;&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Fig. 7: Top 10 data of processing time for each language at $\theta = 1,000,000$.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Figure 7 shows the summing process-time for each language at $\theta = 1,000,000$. The top 10 data are shown in Fig. 7. This figure shows the high performance of languages (g++, Go and Java) compiled by the compiler. There is two interesting points. 1st point is the result of Python using the pyramid method. Python using the pyramid method shows 2 times faster in the processing speed than Node.js with V8 engine. When it thinks that the processing time of Python using the standard method at $\theta = 1,000,000$ is 6.1 s, this is the remarkable data for the pyramid method. And for $\theta = 5,000,000$, the processing speed of Python is 2.6 times faster than that of Node.js. In the 2nd point, for Go and Ruby, it was found that &amp;ldquo;[]byte&amp;rdquo; and &amp;ldquo;&amp;lt;&amp;lt;&amp;rdquo; are predominantly optimized compared to &amp;ldquo;+&amp;rdquo; operator.&lt;/p&gt;

&lt;p&gt;From the results in this study, it was found that the pyramid method is efficient for languages except for GAS. Especially, languages corresponding to the trend of theoretical results are more efficiently. Languages, which have distinctive optimized commands for summing array elements, should use both the special commands and the standard method. Languages which needs to compile should use the standard method. These results can also be used to the visualization of optimization engine.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Following results could be obtained in this study.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The pyramid method for summing array elements is efficient for the languages except for GAS.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Languages with &amp;ldquo;+&amp;rdquo; operator without the optimization can benefit from the pyramid method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Languages, which have distinctive optimized commands for summing array elements, should use both the special commands and the standard method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The pyramid method can be used to evaluate the optimization engine.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The result in this study gave us the possibility of visualization for optimized codes.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://tanaikech.github.io/2016/10/13/improved-algorithms-for-summation-of-array-elements&#34;&gt;&amp;ldquo;Improved Algorithms for Summation of Array Elements&amp;rdquo;, October 13, 2016&lt;/a&gt;
&lt;a name=&#34;ref1&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;appendix&#34;&gt;Appendix&lt;/h2&gt;

&lt;p&gt;Scripts used at this report are &lt;a href=&#34;https://github.com/tanaikech/SOUWA_test_scripts&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>